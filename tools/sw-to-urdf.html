<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SolidWorks è½¬ URDF/Isaac</title>
    <style>
        :root { --bg: #1e1e1e; --panel: #252526; --text: #d4d4d4; --accent: #4ec9b0; --border: #3e3e42; }
        body { font-family: 'Segoe UI', Consolas, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; height: 100vh; display: flex; flex-direction: column; box-sizing: border-box;}
        h2 { margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 10px; color: var(--accent); }
        .container { display: flex; gap: 20px; flex: 1; min-height: 0; }
        .col { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        textarea { flex: 1; background: #111; color: #9cdcfe; border: 1px solid var(--border); padding: 10px; resize: none; font-family: Consolas, monospace; font-size: 13px; }
        .results { flex: 1; overflow-y: auto; background: #1e1e1e; border: 1px solid var(--border); padding: 10px; }
        button { background: #0e639c; color: white; border: none; padding: 12px; cursor: pointer; font-size: 16px; border-radius: 4px; font-weight: bold; }
        button:hover { background: #1177bb; }
        .card { background: var(--panel); border-left: 5px solid var(--accent); padding: 15px; margin-bottom: 15px; border-radius: 4px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .code-box { background: #111; padding: 10px; border: 1px solid #444; color: #ce9178; font-family: Consolas; font-size: 12px; white-space: pre-wrap; position: relative; margin: 10px 0; }
        .copy-btn { position: absolute; top: 5px; right: 5px; background: #333; border: 1px solid #666; color: #ddd; padding: 2px 8px; cursor: pointer; font-size: 11px; }
        .copy-btn:hover { background: #555; }
        .grid { display: grid; grid-template-columns: 120px 1fr; gap: 8px; font-size: 13px; color: #ccc; }
        .val { font-family: Consolas; background: #333; padding: 2px 6px; border-radius: 3px; color: #b5cea8; }
        .label-with-help { display: flex; align-items: center; gap: 6px; }
        .help-icon { display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; background: #4ec9b0; color: #1e1e1e; border-radius: 50%; font-size: 11px; font-weight: bold; cursor: pointer; user-select: none; }
        .help-icon:hover { background: #5dd9c1; }
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 200px; background-color: #333; color: #ddd; text-align: left; border-radius: 4px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -100px; opacity: 0; transition: opacity 0.3s; font-size: 12px; border: 1px solid #4ec9b0; }
        .tooltip .tooltiptext::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #333 transparent transparent transparent; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        .err-log { color: #f14c4c; font-family: Consolas; font-size: 12px; margin-top: 10px; white-space: pre-wrap; }
    </style>
</head>
<body>

    <h2>SolidWorks æŠ¥å‘Šè½¬æ¢å™¨</h2>

    <div class="container">
        <div class="col">
            <div style="font-size:12px; color:#aaa;">å°† SolidWorks æ–‡æœ¬å®Œæ•´ç²˜è´´åˆ°ä¸‹æ–¹ (åŒ…å«è´¨é‡ã€é‡å¿ƒã€Lxxç­‰æ•°æ®):</div>
            <textarea id="input" placeholder="åœ¨æ­¤ç²˜è´´..."></textarea>
            <button onclick="process()">ğŸš€ ç«‹å³è½¬æ¢</button>
            <div id="log" class="err-log"></div>
        </div>

        <div class="col results" id="output">
            <div style="text-align:center; color:#555; margin-top:50px;">ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>
        </div>
    </div>

<script>
    function log(msg, isError=false) {
        const el = document.getElementById('log');
        if(!msg) { el.innerText = ""; return; }
        el.innerText = (isError ? "âŒ " : "â„¹ï¸ ") + msg;
        el.style.color = isError ? "#f14c4c" : "#4ec9b0";
    }

    function process() {
        const text = document.getElementById('input').value;
        const out = document.getElementById('output');
        out.innerHTML = "";
        log(""); // æ¸…ç©ºæ—¥å¿—

        if (!text.trim()) { log("è¯·å…ˆç²˜è´´æ–‡æœ¬!", true); return; }

        // 1. é¢„å¤„ç†ï¼šè§£å†³"åº§æ ‡ç³»"å’Œç©ºæ ¼é—®é¢˜
        // å°† "åº§æ ‡" ç»Ÿä¸€æ›¿æ¢ä¸º "åæ ‡"ï¼Œå°†è¿ç»­ç©ºç™½ç¬¦æ›¿æ¢ä¸ºå•ç©ºæ ¼(ä¿ç•™æ¢è¡Œç”¨äºåˆ†å‰²)
        let cleanText = text.replace(/åº§æ ‡/g, "åæ ‡");

        // 2. å°è¯•åˆ†å‰²é›¶ä»¶ (æŒ‰ "xxx çš„è´¨é‡å±æ€§" åˆ†å‰²)
        let parts = [];
        const splitRegex = /(.+?)\s*çš„è´¨é‡å±æ€§/g;
        let match;
        while ((match = splitRegex.exec(cleanText)) !== null) {
            parts.push({ index: match.index, name: match[1].trim() });
        }

        if (parts.length === 0) {
            // å¦‚æœæ²¡æ‰¾åˆ°æ ‡é¢˜ï¼Œå¼ºåˆ¶æŠŠæ•´æ®µæ–‡æœ¬ä½œä¸ºä¸€ä¸ªé›¶ä»¶å¤„ç†
            parts.push({ index: 0, name: "æœªå‘½åéƒ¨ä»¶" });
        }

        let successCount = 0;

        // 3. é€ä¸ªé›¶ä»¶è§£æ
        for (let i = 0; i < parts.length; i++) {
            const start = parts[i].index;
            const end = (i + 1 < parts.length) ? parts[i+1].index : cleanText.length;
            const content = cleanText.substring(start, end);

            try {
                const data = parseOnePart(content, parts[i].name);
                renderCard(data, out);
                successCount++;
            } catch (e) {
                console.error(e);
                log(`è§£æ "${parts[i].name}" å¤±è´¥: ${e.message}`, true);
            }
        }

        if (successCount > 0) {
            log(`æˆåŠŸè§£æ ${successCount} ä¸ªéƒ¨ä»¶ã€‚`);
        }
    }

    function parseOnePart(txt, name) {
        // --- 1. è·å–è´¨é‡ ---
        const mMatch = txt.match(/è´¨é‡\s*=\s*([\d\.]+)/);
        if (!mMatch) throw new Error("æœªæ‰¾åˆ° 'è´¨é‡ = ...' æ•°æ®");
        const mass = parseFloat(mMatch[1]);

        // --- 2. è·å–é‡å¿ƒ ---
        // ç­–ç•¥ï¼šæ‰¾ "é‡å¿ƒ" å…³é”®å­—åç´§è·Ÿçš„ X, Y, Z
        const comRegex = /é‡å¿ƒ[\s\S]*?X\s*=\s*([-\d\.]+)[\s\S]*?Y\s*=\s*([-\d\.]+)[\s\S]*?Z\s*=\s*([-\d\.]+)/i;
        const cMatch = txt.match(comRegex);
        if (!cMatch) throw new Error("æœªæ‰¾åˆ° 'é‡å¿ƒ' X/Y/Z æ•°æ®");

        // æ¯«ç±³è½¬ç±³
        const com = [
            parseFloat(cMatch[1]) / 1000,
            parseFloat(cMatch[2]) / 1000,
            parseFloat(cMatch[3]) / 1000
        ];

        // --- 3. è·å–æƒ¯æ€§å¼ é‡ (æ ¸å¿ƒéš¾ç‚¹) ---
        // ç­–ç•¥ï¼šå…ˆæ‰¾åˆ° "ç”±é‡å¿ƒå†³å®š...å¯¹é½" è¿™ä¸ªé”šç‚¹ã€‚
        // ç„¶åä»è¿™ä¸ªé”šç‚¹å¼€å§‹ï¼Œå‘åæœå¯» Lxx, Lxy...
        // è¿™æ ·å¯ä»¥é¿å¼€å‰é¢å¯èƒ½å‡ºç°çš„ "Ix, Iy, Iz" (ä¸»è½´) å’Œåé¢çš„ "è¾“å‡ºåæ ‡ç³»"

        const anchorRegex = /ç”±é‡å¿ƒå†³å®š[^(\n]*?å¯¹é½/i;
        const anchorMatch = txt.match(anchorRegex);

        if (!anchorMatch) throw new Error("æœªæ‰¾åˆ° 'ç”±é‡å¿ƒå†³å®š...å¹¶å¯¹é½' çš„æ•°æ®æ®µè½");

        // æˆªå–ä»é”šç‚¹å¼€å§‹çš„ååŠæ®µæ–‡æœ¬
        const inertiaText = txt.substring(anchorMatch.index);

        // æå– Lxx æˆ–è€… Ixx (å¿½ç•¥å¤§å°å†™)
        // ä½ çš„æ–‡æœ¬é‡Œæ˜¯ Lxx, ä¹‹é—´å¯èƒ½æœ‰ tab æˆ–ç©ºæ ¼
        const getVal = (key) => {
            // æ­£åˆ™è§£é‡Šï¼šåŒ¹é… Lxx æˆ– Ixxï¼Œåé¢è·Ÿä»»æ„ç©ºç™½ï¼Œè·Ÿç­‰å·ï¼Œè·Ÿä»»æ„ç©ºç™½ï¼Œè·Ÿæ•°å­—
            const r = new RegExp(`[LI]${key}\\s*=\\s*([-\\d\\.]+)`, 'i');
            const m = inertiaText.match(r);
            if (!m) return 0; // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œé»˜è®¤ä¸º0 (æ¯”å¦‚ Lxyæœ‰æ—¶ä¸æ˜¾ç¤º?) é€šå¸¸éƒ½æœ‰
            return parseFloat(m[1]) / 1000000; // kg*mm^2 -> kg*m^2
        };

        // éªŒè¯è‡³å°‘æ‰¾åˆ°äº† Lxxï¼Œé˜²æ­¢åŒ¹é…é”™ä½ç½®
        if (!inertiaText.match(/[LI]xx\s*=/i)) {
            throw new Error("åœ¨é‡å¿ƒæ®µè½ä¸­æœªæ‰¾åˆ° Lxx/Ixx æ•°æ®");
        }

        const I = [
            [getVal('xx'), getVal('xy'), getVal('xz')],
            [getVal('yx'), getVal('yy'), getVal('yz')],
            [getVal('zx'), getVal('zy'), getVal('zz')]
        ];

        // è®¡ç®— Isaac Sim å‚æ•°
        const isaac = calculateIsaac(I);

        return { name, mass, com, urdf: I, isaac };
    }

    function renderCard(d, container) {
        try {
            const fmt = n => n.toExponential(5);
            const fmtFix = n => n.toFixed(6);

            // URDF Matrix
            const ixx=fmt(d.urdf[0][0]), ixy=fmt(d.urdf[0][1]), ixz=fmt(d.urdf[0][2]);
            const iyy=fmt(d.urdf[1][1]), iyz=fmt(d.urdf[1][2]), izz=fmt(d.urdf[2][2]);

            const urdfStr = `<link name="${d.name}">
  <inertial>
    <origin xyz="${fmtFix(d.com[0])} ${fmtFix(d.com[1])} ${fmtFix(d.com[2])}" rpy="0 0 0" />
    <mass value="${d.mass}" />
    <inertia ixx="${ixx}" ixy="${ixy}" ixz="${ixz}" iyy="${iyy}" iyz="${iyz}" izz="${izz}" />
  </inertial>
</link>`;

            // Isaac Data
            const diagStr = d.isaac.eigenvalues.map(fmt).join(', ');
            const euler = d.isaac.euler;
            const eulerStr = `${euler.roll.toFixed(2)}Â°, ${euler.pitch.toFixed(2)}Â°, ${euler.yaw.toFixed(2)}Â°`;

            const div = document.createElement('div');
            div.className = 'card';
            div.innerHTML = `
                <div style="font-weight:bold; color:#4ec9b0; margin-bottom:10px;">
                    ${d.name} <span style="font-size:11px; color:#666; font-weight:normal;">(å•ä½å·²è‡ªåŠ¨æ¢ç®—)</span>
                </div>

                <div class="code-box">${escapeHtml(urdfStr)}<button class="copy-btn" onclick="copyToClip(this)">å¤åˆ¶ URDF</button></div>

                <div class="grid">
                    <div class="label-with-help">
                        <span>Mass</span>
                    </div>
                    <span class="val">${d.mass}</span>

                    <div class="label-with-help">
                        <span>CoM (m)</span>
                        <div class="tooltip">
                            <span class="help-icon">?</span>
                            <span class="tooltiptext">Center of Mass coordinates in meters (X, Y, Z)</span>
                        </div>
                    </div>
                    <span class="val">${fmtFix(d.com[0])}, ${fmtFix(d.com[1])}, ${fmtFix(d.com[2])}</span>

                    <div class="label-with-help">
                        <span>Diagonal Inertia</span>
                    </div>
                    <span class="val">${diagStr}</span>

                    <div class="label-with-help">
                        <span>Principal Axes</span>
                        <div class="tooltip">
                            <span class="help-icon">?</span>
                            <span class="tooltiptext">Euler angles in degrees (Roll/X, Pitch/Y, Yaw/Z)</span>
                        </div>
                    </div>
                    <span class="val">${eulerStr}</span>
                </div>
            `;
            container.appendChild(div);
        } catch(e) {
            console.error("Render error:", e);
            const div = document.createElement('div');
            div.className = 'card';
            div.innerHTML = `<div style="color:#f14c4c;">æ¸²æŸ“å¤±è´¥: ${e.message}</div>`;
            container.appendChild(div);
        }
    }

    // --- æ•°å­¦å·¥å…· ---
    function copyToClip(btn) {
        const txt = btn.parentElement.innerText.replace("å¤åˆ¶ URDF", "");
        navigator.clipboard.writeText(txt).then(() => {
            const originText = btn.innerText;
            btn.innerText = "å·²å¤åˆ¶!";
            setTimeout(() => btn.innerText = originText, 1000);
        });
    }
    function escapeHtml(t) { return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); }

    // Jacobi & Quat Algorithm
    function calculateIsaac(m) {
        try {
            const res = jacobi(m);
            const quat = rotationMatrixToQuaternion(res.eigenvectors);
            const euler = quaternionToEuler(quat);
            return { eigenvalues: res.eigenvalues, quat: quat, euler: euler };
        } catch(e) {
            console.error("Isaac calculation error:", e);
            return {
                eigenvalues: [0, 0, 0],
                quat: {w: 1, x: 0, y: 0, z: 0},
                euler: {roll: 0, pitch: 0, yaw: 0}
            };
        }
    }

    function jacobi(A_in) {
        let n = 3;
        let A = JSON.parse(JSON.stringify(A_in));
        let V = [[1,0,0],[0,1,0],[0,0,1]];
        let maxIter = 50;

        for(let iter = 0; iter < maxIter; iter++) {
            let maxVal = 0;
            let p = 0, q = 0;

            for(let i = 0; i < n-1; i++) {
                for(let j = i+1; j < n; j++) {
                    if(Math.abs(A[i][j]) > maxVal) {
                        maxVal = Math.abs(A[i][j]);
                        p = i;
                        q = j;
                    }
                }
            }

            if(maxVal < 1e-15) break;

            let phi;
            if(A[p][p] === A[q][q]) {
                phi = Math.PI / 4;
            } else {
                phi = 0.5 * Math.atan(2 * A[p][q] / (A[p][p] - A[q][q]));
            }

            let c = Math.cos(phi);
            let s = Math.sin(phi);
            let App = c*c*A[p][p] + s*s*A[q][q] + 2*c*s*A[p][q];
            let Aqq = s*s*A[p][p] + c*c*A[q][q] - 2*c*s*A[p][q];

            A[p][q] = 0;
            A[q][p] = 0;
            A[p][p] = App;
            A[q][q] = Aqq;

            for(let i = 0; i < n; i++) {
                if(i !== p && i !== q) {
                    let Aip = c*A[i][p] + s*A[i][q];
                    let Aiq = -s*A[i][p] + c*A[i][q];
                    A[i][p] = Aip;
                    A[p][i] = Aip;
                    A[i][q] = Aiq;
                    A[q][i] = Aiq;
                }
            }

            for(let i = 0; i < n; i++) {
                let Vip = c*V[i][p] + s*V[i][q];
                let Viq = -s*V[i][p] + c*V[i][q];
                V[i][p] = Vip;
                V[i][q] = Viq;
            }
        }

        return {
            eigenvalues: [A[0][0], A[1][1], A[2][2]],
            eigenvectors: V
        };
    }

    function rotationMatrixToQuaternion(R) {
        let tr = R[0][0] + R[1][1] + R[2][2];
        let qw, qx, qy, qz;

        if(tr > 0) {
            let S = Math.sqrt(tr + 1.0) * 2;
            qw = 0.25 * S;
            qx = (R[2][1] - R[1][2]) / S;
            qy = (R[0][2] - R[2][0]) / S;
            qz = (R[1][0] - R[0][1]) / S;
        } else if((R[0][0] > R[1][1]) && (R[0][0] > R[2][2])) {
            let S = Math.sqrt(1.0 + R[0][0] - R[1][1] - R[2][2]) * 2;
            qw = (R[2][1] - R[1][2]) / S;
            qx = 0.25 * S;
            qy = (R[0][1] + R[1][0]) / S;
            qz = (R[0][2] + R[2][0]) / S;
        } else if(R[1][1] > R[2][2]) {
            let S = Math.sqrt(1.0 + R[1][1] - R[0][0] - R[2][2]) * 2;
            qw = (R[0][2] - R[2][0]) / S;
            qx = (R[0][1] + R[1][0]) / S;
            qy = 0.25 * S;
            qz = (R[1][2] + R[2][1]) / S;
        } else {
            let S = Math.sqrt(1.0 + R[2][2] - R[0][0] - R[1][1]) * 2;
            qw = (R[1][0] - R[0][1]) / S;
            qx = (R[0][2] + R[2][0]) / S;
            qy = (R[1][2] + R[2][1]) / S;
            qz = 0.25 * S;
        }

        return {w: qw, x: qx, y: qy, z: qz};
    }

    function quaternionToEuler(q) {
        // å››å…ƒæ•°è½¬æ¬§æ‹‰è§’ (ZYX é¡ºåºï¼Œè¿”å›åº¦æ•°)
        // q = {w, x, y, z}

        // Roll (ç»• X è½´)
        const sinr_cosp = 2 * (q.w * q.x + q.y * q.z);
        const cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y);
        const roll = Math.atan2(sinr_cosp, cosr_cosp);

        // Pitch (ç»• Y è½´)
        const sinp = 2 * (q.w * q.y - q.z * q.x);
        const pitch = Math.asin(Math.max(-1, Math.min(1, sinp)));

        // Yaw (ç»• Z è½´)
        const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
        const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
        const yaw = Math.atan2(siny_cosp, cosy_cosp);

        // è½¬æ¢ä¸ºåº¦æ•°
        return {
            roll: roll * 180 / Math.PI,
            pitch: pitch * 180 / Math.PI,
            yaw: yaw * 180 / Math.PI
        };
    }
</script>
</body>
</html>
