<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLOT.tab æ›²çº¿å›¾å·¥å…· (ç¦»çº¿ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- å†…åµŒç®€å•çš„å›¾è¡¨åº“ -->
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .drop-zone {
            border: 3px dashed #4CAF50;
            border-radius: 10px;
            padding: 60px 20px;
            text-align: center;
            background-color: white;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #45a049;
            background-color: #f9f9f9;
            transform: scale(1.02);
        }
        
        .drop-zone p {
            margin: 10px 0;
            font-size: 18px;
            color: #666;
        }
        
        .drop-zone .icon {
            font-size: 48px;
            color: #4CAF50;
            margin-bottom: 20px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        
        .controls h3 {
            margin-top: 0;
            color: #333;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .checkbox-item input[type="checkbox"] {
            margin: 0;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        
        .file-info {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        
        button:hover {
            background: #45a049;
        }

        .export-button {
            background: #FF9800;
        }

        .export-button:hover {
            background: #F57C00;
        }
        
        /* ç®€å•çš„SVGå›¾è¡¨æ ·å¼ */
        .simple-chart {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            background: white;
        }
        
        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 10px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
        }
        
        .chart-title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .help-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }
        
        .help-button:hover {
            background: #1976D2;
        }
        
        .help-panel {
            display: none;
            background: #f0f8ff;
            border: 1px solid #2196F3;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .help-panel h4 {
            margin: 0 0 10px 0;
            color: #1976D2;
        }
        
        .help-panel p {
            margin: 8px 0;
            line-height: 1.4;
            font-size: 14px;
        }
        
        .help-panel .filter-info {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .help-panel .filter-info:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .help-panel .highlight {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        /* Tooltipæ ·å¼ */
        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            font-family: monospace;
            pointer-events: none;
            z-index: 9999;
            display: none;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .chart-tooltip .tooltip-time {
            color: #66ccff;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .chart-tooltip .tooltip-value {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        
        .chart-tooltip .tooltip-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            margin-right: 6px;
        }
        
        /* å›¾è¡¨äº¤äº’æ ·å¼ */
        .chart-point {
            cursor: pointer;
            opacity: 0.7;
        }
        
        .chart-point:hover {
            opacity: 1;
            r: 6;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ“Š æ•°æ®æ›²çº¿å›¾å·¥å…· (ç¦»çº¿ç‰ˆ)</h1>
        <p>å°†æ‚¨çš„æ•°æ®æ–‡ä»¶æ‹–æ‹½åˆ°ä¸‹æ–¹åŒºåŸŸï¼Œè‡ªåŠ¨ç”Ÿæˆæ›²çº¿å›¾</p>
        <p><small>æ”¯æŒæ ¼å¼ï¼š.tab, .txt, .csv, .tsv, .dat | æ­¤ç‰ˆæœ¬æ— éœ€ç½‘ç»œè¿æ¥</small></p>
    </div>

    <div class="drop-zone" id="dropZone">
        <div class="icon">ğŸ“</div>
        <p><strong>æ‹–æ‹½æ•°æ®æ–‡ä»¶åˆ°è¿™é‡Œ</strong></p>
        <p>æ”¯æŒ .tab/.txt/.csv/.tsv/.dat æ ¼å¼</p>
        <p>æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
        <input type="file" id="fileInput" accept=".tab,.txt,.csv,.tsv,.dat" style="display: none;">
    </div>

    <div class="error" id="errorDiv"></div>
    
    <div class="file-info" id="fileInfo"></div>

    <div class="controls" id="controls">
        <h3>å›¾è¡¨è®¾ç½®</h3>
        
        <div class="control-group">
            <label>é€‰æ‹©è¦æ˜¾ç¤ºçš„æ•°æ®åˆ—ï¼š
                <button type="button" class="help-button" onclick="toggleSelectAll()" id="selectAllBtn">âœ“ å…¨é€‰</button>
            </label>
            
            <!-- æœç´¢ç­›é€‰åŒºåŸŸ -->
            <div style="margin: 10px 0; display: flex; gap: 10px; align-items: center;">
                <input type="text" id="columnSearch" placeholder="æœç´¢æ•°æ®åˆ— (å¦‚: rb, motion, power...)" 
                       style="flex: 1; padding: 6px 10px; border: 1px solid #ddd; border-radius: 3px; font-size: 13px;"
                       oninput="filterColumns()" onkeyup="filterColumns()">
                <button type="button" onclick="clearColumnSearch()" 
                        style="background: #666; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                    æ¸…é™¤
                </button>
                <button type="button" onclick="toggleFilteredSelectAll()" id="filteredSelectAllBtn"
                        style="background: #2196F3; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                    âœ“ ç­›é€‰å…¨é€‰
                </button>
            </div>
            
            <div class="checkbox-group" id="columnCheckboxes"></div>
        </div>

        <div class="control-group">
            <label for="lineStyle">æ›²çº¿æ ·å¼ï¼š</label>
            <select id="lineStyle" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px;">
                <option value="smooth">å¹³æ»‘æ›²çº¿ (æ¨è)</option>
                <option value="linear">ç›´çº¿è¿æ¥</option>
                <option value="stepped">é˜¶æ¢¯çŠ¶</option>
                <option value="points">ä»…æ˜¾ç¤ºæ•°æ®ç‚¹</option>
            </select>
        </div>

        <div class="control-group">
            <label>æ•°æ®æ»¤æ³¢å™¨ï¼š
                <button type="button" class="help-button" onclick="toggleFilterHelp()">â“ å¸®åŠ©</button>
            </label>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" id="enableFilter">
                <label for="enableFilter" style="margin: 0; font-weight: normal;">å¯ç”¨æ»¤æ³¢</label>
            </div>
            <div id="filterControls" style="display: none; border: 1px solid #ddd; padding: 15px; border-radius: 5px; background: #f9f9f9;">
                <div style="margin-bottom: 10px;">
                    <label for="filterType">æ»¤æ³¢å™¨ç±»å‹ï¼š</label>
                    <select id="filterType" style="width: 100%; padding: 5px; margin-top: 5px;" onchange="updateFilterHelp()">
                        <option value="movingAverage">ç§»åŠ¨å¹³å‡æ»¤æ³¢</option>
                        <option value="gaussian">é«˜æ–¯æ»¤æ³¢</option>
                        <option value="butterworth">å·´ç‰¹æ²ƒæ–¯ä½é€šæ»¤æ³¢</option>
                        <option value="median">ä¸­å€¼æ»¤æ³¢</option>
                        <option value="kalman">ç®€å•å¡å°”æ›¼æ»¤æ³¢</option>
                    </select>
                </div>
                <div id="filterParams">
                    <label for="windowSize">çª—å£å¤§å°/å¼ºåº¦ï¼š</label>
                    <input type="range" id="windowSize" min="3" max="50" value="5" style="width: 100%;">
                    <span id="windowSizeValue">5</span>
                </div>
            </div>
            
            <!-- æ»¤æ³¢å™¨å¸®åŠ©é¢æ¿ -->
            <div id="filterHelpPanel" class="help-panel">
                <div id="movingAverageHelp" class="filter-info">
                    <h4>ğŸ“Š ç§»åŠ¨å¹³å‡æ»¤æ³¢</h4>
                    <p><strong>ç‰¹ç‚¹ï¼š</strong>ç®€å•æœ‰æ•ˆçš„å™ªå£°å¹³æ»‘ç®—æ³•ï¼Œé€šè¿‡è®¡ç®—é‚»è¿‘ç‚¹çš„å¹³å‡å€¼æ¥å‡å°‘éšæœºå™ªå£°ã€‚</p>
                    <p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
                    <p>â€¢ æ•°æ®æœ‰éšæœºå™ªå£°ä½†è¶‹åŠ¿æ˜æ˜¾</p>
                    <p>â€¢ éœ€è¦ç®€å•å¿«é€Ÿçš„å¹³æ»‘æ•ˆæœ</p>
                    <p>â€¢ ä¼ æ„Ÿå™¨æ•°æ®é¢„å¤„ç†</p>
                    <p><strong>çª—å£å¤§å°é€‰æ‹©ï¼š</strong></p>
                    <p>â€¢ <span class="highlight">3-7</span>ï¼šè½»å¾®å¹³æ»‘ï¼Œä¿æŒç»†èŠ‚</p>
                    <p>â€¢ <span class="highlight">8-15</span>ï¼šä¸­ç­‰å¹³æ»‘ï¼Œå¹³è¡¡å™ªå£°å’Œç»†èŠ‚</p>
                    <p>â€¢ <span class="highlight">16+</span>ï¼šå¼ºçƒˆå¹³æ»‘ï¼Œçªå‡ºä¸»è¦è¶‹åŠ¿</p>
                </div>
                
                <div id="gaussianHelp" class="filter-info">
                    <h4>ğŸ”” é«˜æ–¯æ»¤æ³¢</h4>
                    <p><strong>ç‰¹ç‚¹ï¼š</strong>åŸºäºé«˜æ–¯åˆ†å¸ƒçš„åŠ æƒå¹³å‡ï¼Œèƒ½æ›´å¥½åœ°ä¿æŒä¿¡å·çš„è¾¹ç¼˜ç‰¹å¾ï¼Œå¹³æ»‘æ•ˆæœè‡ªç„¶ã€‚</p>
                    <p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
                    <p>â€¢ éœ€è¦ä¿æŒä¿¡å·è¾¹ç¼˜å’Œç‰¹å¾ç‚¹</p>
                    <p>â€¢ å›¾åƒå¤„ç†æˆ–ç²¾å¯†æµ‹é‡æ•°æ®</p>
                    <p>â€¢ è¦æ±‚é«˜è´¨é‡å¹³æ»‘æ•ˆæœ</p>
                    <p><strong>å¼ºåº¦é€‰æ‹©ï¼š</strong></p>
                    <p>â€¢ <span class="highlight">3-8</span>ï¼šè½»å¾®å¹³æ»‘ï¼Œä¿æŒåŸå§‹ç‰¹å¾</p>
                    <p>â€¢ <span class="highlight">9-20</span>ï¼šé€‚ä¸­å¹³æ»‘ï¼Œå»é™¤ä¸­é¢‘å™ªå£°</p>
                    <p>â€¢ <span class="highlight">21+</span>ï¼šå¼ºçƒˆå¹³æ»‘ï¼Œä»…ä¿ç•™ä¸»è¦è¶‹åŠ¿</p>
                </div>
                
                <div id="butterworthHelp" class="filter-info">
                    <h4>ğŸŒŠ å·´ç‰¹æ²ƒæ–¯ä½é€šæ»¤æ³¢</h4>
                    <p><strong>ç‰¹ç‚¹ï¼š</strong>ç»å…¸çš„é¢‘åŸŸæ»¤æ³¢å™¨ï¼Œèƒ½æœ‰æ•ˆå»é™¤é«˜é¢‘å™ªå£°ï¼Œä¿æŒä½é¢‘ä¿¡å·å®Œæ•´æ€§ã€‚</p>
                    <p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
                    <p>â€¢ ä¿¡å·å¤„ç†å’Œé¢‘è°±åˆ†æ</p>
                    <p>â€¢ å»é™¤å·²çŸ¥é¢‘ç‡èŒƒå›´çš„å™ªå£°</p>
                    <p>â€¢ æŒ¯åŠ¨ã€å£°å­¦æ•°æ®å¤„ç†</p>
                    <p><strong>å¼ºåº¦é€‰æ‹©ï¼š</strong></p>
                    <p>â€¢ <span class="highlight">5-15</span>ï¼šä¿ç•™æ›´å¤šé«˜é¢‘æˆåˆ†</p>
                    <p>â€¢ <span class="highlight">16-30</span>ï¼šå¹³è¡¡çš„é¢‘ç‡å“åº”</p>
                    <p>â€¢ <span class="highlight">31+</span>ï¼šå¼ºçƒˆæŠ‘åˆ¶é«˜é¢‘å™ªå£°</p>
                </div>
                
                <div id="medianHelp" class="filter-info">
                    <h4>âš¡ ä¸­å€¼æ»¤æ³¢</h4>
                    <p><strong>ç‰¹ç‚¹ï¼š</strong>å–çª—å£å†…æ•°å€¼çš„ä¸­ä½æ•°ï¼Œèƒ½æœ‰æ•ˆå»é™¤è„‰å†²å™ªå£°å’Œå¼‚å¸¸å€¼ï¼ŒåŒæ—¶ä¿æŒè¾¹ç¼˜ã€‚</p>
                    <p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
                    <p>â€¢ æ•°æ®æœ‰å°–å³°å™ªå£°æˆ–å¼‚å¸¸å€¼</p>
                    <p>â€¢ éœ€è¦ä¿æŒä¿¡å·è·³å˜è¾¹ç¼˜</p>
                    <p>â€¢ æ•°å­—å›¾åƒå»å™ª</p>
                    <p><strong>çª—å£å¤§å°é€‰æ‹©ï¼š</strong></p>
                    <p>â€¢ <span class="highlight">3-5</span>ï¼šå»é™¤å°çš„å¼‚å¸¸ç‚¹</p>
                    <p>â€¢ <span class="highlight">6-12</span>ï¼šå¤„ç†ä¸­ç­‰è„‰å†²å™ªå£°</p>
                    <p>â€¢ <span class="highlight">13+</span>ï¼šå»é™¤å¤§èŒƒå›´å¼‚å¸¸åŒºåŸŸ</p>
                </div>
                
                <div id="kalmanHelp" class="filter-info">
                    <h4>ğŸ¯ ç®€å•å¡å°”æ›¼æ»¤æ³¢</h4>
                    <p><strong>ç‰¹ç‚¹ï¼š</strong>åŸºäºçŠ¶æ€ä¼°è®¡çš„è‡ªé€‚åº”æ»¤æ³¢å™¨ï¼Œèƒ½æ ¹æ®ä¿¡å·å˜åŒ–åŠ¨æ€è°ƒæ•´æ»¤æ³¢å¼ºåº¦ã€‚</p>
                    <p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
                    <p>â€¢ åŠ¨æ€ç³»ç»ŸçŠ¶æ€ä¼°è®¡</p>
                    <p>â€¢ ä¼ æ„Ÿå™¨èåˆå’Œå¯¼èˆª</p>
                    <p>â€¢ éœ€è¦è·Ÿè¸ªä¿¡å·å˜åŒ–è¶‹åŠ¿</p>
                    <p><strong>è¿‡ç¨‹å™ªå£°é€‰æ‹©ï¼š</strong></p>
                    <p>â€¢ <span class="highlight">5-15</span>ï¼šä¿¡å·å˜åŒ–è¾ƒæ…¢</p>
                    <p>â€¢ <span class="highlight">16-30</span>ï¼šä¸­ç­‰åŠ¨æ€ç‰¹æ€§</p>
                    <p>â€¢ <span class="highlight">31+</span>ï¼šå¿«é€Ÿå˜åŒ–çš„åŠ¨æ€ä¿¡å·</p>
                </div>
                
                <div style="background: #e8f4f8; padding: 10px; border-radius: 5px; margin-top: 15px;">
                    <h4>ğŸ’¡ é€‰æ‹©å»ºè®®</h4>
                    <p><strong>å™ªå£°ç±»å‹è¯†åˆ«ï¼š</strong></p>
                    <p>â€¢ éšæœºå™ªå£° â†’ ç§»åŠ¨å¹³å‡æˆ–é«˜æ–¯æ»¤æ³¢</p>
                    <p>â€¢ è„‰å†²å™ªå£° â†’ ä¸­å€¼æ»¤æ³¢</p>
                    <p>â€¢ é«˜é¢‘å™ªå£° â†’ å·´ç‰¹æ²ƒæ–¯æ»¤æ³¢</p>
                    <p>â€¢ åŠ¨æ€ä¿¡å· â†’ å¡å°”æ›¼æ»¤æ³¢</p>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="chartTitle">å›¾è¡¨æ ‡é¢˜ï¼š</label>
            <input type="text" id="chartTitle" value="æ•°æ®æ›²çº¿å›¾" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px;">
        </div>
        
        <div class="control-group">
            <label>æ—¶é—´èŒƒå›´é™åˆ¶ï¼ˆå¯é€‰ï¼‰ï¼š</label>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" id="enableTimeRange">
                <label for="enableTimeRange" style="margin: 0; font-weight: normal;">å¯ç”¨æ—¶é—´èŒƒå›´é™åˆ¶</label>
            </div>
            <div id="timeRangeControls" style="display: none; border: 1px solid #ddd; padding: 15px; border-radius: 5px; background: #f9f9f9;">
                <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <label for="timeStart" style="display: block; margin-bottom: 5px; font-size: 13px;">å¼€å§‹æ—¶é—´ï¼š</label>
                        <input type="number" id="timeStart" placeholder="æœ€å°æ—¶é—´å€¼" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 3px;" 
                               step="any" onchange="updateTimeRange()">
                    </div>
                    <div style="flex: 1;">
                        <label for="timeEnd" style="display: block; margin-bottom: 5px; font-size: 13px;">ç»“æŸæ—¶é—´ï¼š</label>
                        <input type="number" id="timeEnd" placeholder="æœ€å¤§æ—¶é—´å€¼" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 3px;" 
                               step="any" onchange="updateTimeRange()">
                    </div>
                    <div>
                        <button type="button" onclick="resetTimeRange()" 
                                style="background: #666; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; margin-top: 20px;">
                            é‡ç½®
                        </button>
                    </div>
                </div>
                <div id="timeRangeInfo" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="timePointQuery">æŸ¥çœ‹ç‰¹å®šæ—¶é—´ç‚¹æ•°æ®ï¼š</label>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
                <input type="number" id="timePointInput" placeholder="è¾“å…¥æ—¶é—´å€¼" 
                       style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 3px;" 
                       step="any" onkeypress="if(event.key==='Enter') queryTimePoint()">
                <button type="button" onclick="queryTimePoint()" style="background: #2196F3; min-width: 80px;">æŸ¥è¯¢</button>
            </div>
            <div id="timePointResult" style="margin-top: 10px; padding: 10px; background: #f0f8ff; 
                                          border-radius: 5px; display: none; font-family: monospace; font-size: 13px;
                                          border: 1px solid #2196F3;"></div>
        </div>
        
        <button onclick="updateChart()">æ›´æ–°å›¾è¡¨</button>
        <button class="export-button" onclick="exportToExcel()" id="exportBtn" style="display: none;">ğŸ“Š å¯¼å‡ºExcel</button>
    </div>

    <div class="chart-container" id="chartContainer">
        <div class="chart-title" id="chartTitleDisplay">æ•°æ®æ›²çº¿å›¾</div>
        <div class="chart-legend" id="chartLegend"></div>
        <svg class="simple-chart" id="chart"></svg>
        <!-- Tooltipå…ƒç´  -->
        <div id="chartTooltip" class="chart-tooltip"></div>
    </div>

    <script>
        let fileData = null;
        let originalData = null; // ä¿å­˜åŸå§‹æ•°æ®
        
        // æ•°æ®æ ¼å¼åŒ–å‡½æ•°
        function formatNumber(value) {
            if (typeof value !== 'number' || isNaN(value)) {
                return '0';
            }
            
            // å»é™¤é€—å·åˆ†éš”ç¬¦ï¼Œç›´æ¥æ˜¾ç¤ºæ•°å­—
            if (Math.abs(value) < 0.001 && value !== 0) {
                // ç§‘å­¦è®°æ•°æ³•æ˜¾ç¤ºéå¸¸å°çš„æ•°
                return value.toExponential(3);
            } else if (Math.abs(value) >= 1000000) {
                // å¤§æ•°å­—ä½¿ç”¨ç§‘å­¦è®°æ•°æ³•æˆ–ç®€åŒ–æ˜¾ç¤º
                return value.toExponential(3);
            } else {
                // ä¿ç•™åˆé€‚çš„å°æ•°ä½æ•°
                let decimals = Math.abs(value) >= 1 ? 2 : 4;
                return value.toFixed(decimals).replace(/\.?0+$/, ''); // å»é™¤æœ«å°¾çš„0
            }
        }
        
        // Tooltipç›¸å…³å‡½æ•°
        function showTooltip(event, timeValue, dataValues, selectedColumns) {
            const tooltip = document.getElementById('chartTooltip');
            if (!tooltip) {
                return;
            }
            
            const timeColumn = fileData.headers[0];
            
            let tooltipContent = `<div class="tooltip-time">${timeColumn}: ${formatNumber(timeValue)}</div>`;
            
            selectedColumns.forEach((column, index) => {
                const color = getChartColor(index);
                const value = dataValues[column];
                tooltipContent += `
                    <div class="tooltip-value">
                        <div class="tooltip-color" style="background-color: ${color}"></div>
                        <span>${column}: ${formatNumber(value)}</span>
                    </div>
                `;
            });
            
            tooltip.innerHTML = tooltipContent;
            
            // æ˜¾ç¤ºtooltip
            tooltip.style.display = 'block';
            tooltip.style.visibility = 'visible';
            tooltip.style.opacity = '1';
            
            // è·å–tooltipå°ºå¯¸
            const tooltipRect = tooltip.getBoundingClientRect();
            
            // è®¡ç®—ç›¸å¯¹äºé¡µé¢çš„ä½ç½®
            let left = event.pageX + 15;
            let top = event.pageY - 10;
            
            // é˜²æ­¢tooltipè¶…å‡ºè§†çª—è¾¹ç•Œ
            if (left + tooltipRect.width > window.innerWidth) {
                left = event.pageX - tooltipRect.width - 15;
            }
            if (top < window.pageYOffset) {
                top = event.pageY + 20;
            }
            if (top + tooltipRect.height > window.innerHeight + window.pageYOffset) {
                top = event.pageY - tooltipRect.height - 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('chartTooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
                tooltip.style.visibility = 'hidden';
                tooltip.style.opacity = '0';
            }
        }
        
        // æ—¶é—´ç‚¹æŸ¥è¯¢åŠŸèƒ½
        function queryTimePoint() {
            if (!fileData || !originalData) {
                alert('è¯·å…ˆåŠ è½½æ•°æ®æ–‡ä»¶');
                return;
            }
            
            const timeInput = document.getElementById('timePointInput');
            const resultDiv = document.getElementById('timePointResult');
            const queryTime = parseFloat(timeInput.value);
            
            if (isNaN(queryTime)) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ—¶é—´å€¼');
                return;
            }
            
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            
            // æŸ¥æ‰¾æœ€æ¥è¿‘çš„æ—¶é—´ç‚¹
            let closestIndex = 0;
            let minDiff = Math.abs(timeValues[0] - queryTime);
            
            for (let i = 1; i < timeValues.length; i++) {
                const diff = Math.abs(timeValues[i] - queryTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }
            
            const closestTime = timeValues[closestIndex];
            const closestData = originalData[closestIndex];
            
            // ç”Ÿæˆç»“æœæ˜¾ç¤º
            let resultHTML = `<strong>ğŸ¯ æŸ¥è¯¢æ—¶é—´: ${formatNumber(queryTime)}</strong><br>`;
            resultHTML += `<strong>ğŸ“ æœ€æ¥è¿‘æ—¶é—´: ${formatNumber(closestTime)}</strong>`;
            
            if (Math.abs(closestTime - queryTime) > 0.001) {
                resultHTML += ` <span style="color: #666;">(åå·®: ${formatNumber(Math.abs(closestTime - queryTime))})</span>`;
            }
            
            resultHTML += `<br><br><strong>ğŸ“Š è¯¥æ—¶åˆ»æ‰€æœ‰æ•°æ®:</strong><br>`;
            
            // æ˜¾ç¤ºæ‰€æœ‰åˆ—çš„æ•°æ®
            fileData.headers.forEach((header, index) => {
                const value = closestData[header];
                const color = index === 0 ? '#2196F3' : getChartColor(index - 1); // æ—¶é—´åˆ—ç”¨è“è‰²ï¼Œå…¶ä»–ç”¨æ›²çº¿é¢œè‰²
                resultHTML += `<div style="margin: 3px 0; display: flex; align-items: center;">`;
                
                if (index > 0) { // éæ—¶é—´åˆ—æ˜¾ç¤ºé¢œè‰²å—
                    resultHTML += `<div style="width: 12px; height: 12px; background-color: ${color}; 
                                    border-radius: 2px; margin-right: 8px;"></div>`;
                }
                
                resultHTML += `<span style="color: ${color}; font-weight: ${index === 0 ? 'bold' : 'normal'};">
                                ${header}: ${formatNumber(value)}</span></div>`;
            });
            
            // å¦‚æœå¯ç”¨äº†æ»¤æ³¢ï¼Œä¹Ÿæ˜¾ç¤ºæ»¤æ³¢åçš„æ•°æ®
            const enableFilter = document.getElementById('enableFilter').checked;
            if (enableFilter) {
                const filterType = document.getElementById('filterType').value;
                const windowSize = parseInt(document.getElementById('windowSize').value);
                
                // è·å–é€‰ä¸­çš„åˆ—
                const selectedColumns = Array.from(document.querySelectorAll('#columnCheckboxes input:checked'))
                    .map(cb => cb.value);
                
                if (selectedColumns.length > 0) {
                    resultHTML += `<br><strong>ğŸ”§ ${getFilterName(filterType)}æ»¤æ³¢åæ•°æ®:</strong><br>`;
                    
                    // è®¡ç®—æ»¤æ³¢åçš„æ•°æ®
                    let filteredData = originalData.map(row => ({ ...row }));
                    
                    selectedColumns.forEach((column, colIndex) => {
                        const originalValues = originalData.map(row => row[column]);
                        let filteredValues;
                        
                        switch (filterType) {
                            case 'movingAverage':
                                filteredValues = Filters.movingAverage(originalValues, windowSize);
                                break;
                            case 'gaussian':
                                filteredValues = Filters.gaussian(originalValues, windowSize / 3);
                                break;
                            case 'butterworth':
                                filteredValues = Filters.butterworth(originalValues, windowSize);
                                break;
                            case 'median':
                                filteredValues = Filters.median(originalValues, windowSize);
                                break;
                            case 'kalman':
                                filteredValues = Filters.kalman(originalValues, windowSize);
                                break;
                            default:
                                filteredValues = originalValues;
                        }
                        
                        filteredData.forEach((row, index) => {
                            row[column] = filteredValues[index];
                        });
                    });
                    
                    const filteredClosestData = filteredData[closestIndex];
                    
                    selectedColumns.forEach((column, colIndex) => {
                        const value = filteredClosestData[column];
                        const color = getChartColor(colIndex);
                        resultHTML += `<div style="margin: 3px 0; display: flex; align-items: center;">`;
                        resultHTML += `<div style="width: 12px; height: 12px; background-color: ${color}; 
                                        border-radius: 2px; margin-right: 8px;"></div>`;
                        resultHTML += `<span style="color: ${color};">${column}: ${formatNumber(value)}</span></div>`;
                    });
                }
            }
            
            resultDiv.innerHTML = resultHTML;
            resultDiv.style.display = 'block';
            
            // æ»šåŠ¨åˆ°ç»“æœåŒºåŸŸ
            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // æ»¤æ³¢å™¨å®ç° (ä¸åœ¨çº¿ç‰ˆæœ¬ç›¸åŒ)
        const Filters = {
            // ç§»åŠ¨å¹³å‡æ»¤æ³¢
            movingAverage: function(data, windowSize) {
                const result = [];
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < data.length; i++) {
                    let sum = 0;
                    let count = 0;
                    
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(data.length - 1, i + halfWindow); j++) {
                        sum += data[j];
                        count++;
                    }
                    
                    result.push(sum / count);
                }
                
                return result;
            },
            
            // é«˜æ–¯æ»¤æ³¢
            gaussian: function(data, sigma) {
                const kernelSize = Math.max(3, Math.ceil(sigma * 3) * 2 + 1);
                const kernel = [];
                const halfKernel = Math.floor(kernelSize / 2);
                let kernelSum = 0;
                
                // ç”Ÿæˆé«˜æ–¯æ ¸
                for (let i = 0; i < kernelSize; i++) {
                    const x = i - halfKernel;
                    const value = Math.exp(-(x * x) / (2 * sigma * sigma));
                    kernel.push(value);
                    kernelSum += value;
                }
                
                // å½’ä¸€åŒ–æ ¸
                for (let i = 0; i < kernel.length; i++) {
                    kernel[i] /= kernelSum;
                }
                
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    let sum = 0;
                    let weightSum = 0;
                    
                    for (let j = 0; j < kernelSize; j++) {
                        const dataIndex = i - halfKernel + j;
                        if (dataIndex >= 0 && dataIndex < data.length) {
                            sum += data[dataIndex] * kernel[j];
                            weightSum += kernel[j];
                        }
                    }
                    
                    result.push(sum / weightSum);
                }
                
                return result;
            },
            
            // ç®€å•ä½é€šæ»¤æ³¢å™¨ï¼ˆå·´ç‰¹æ²ƒæ–¯è¿‘ä¼¼ï¼‰
            butterworth: function(data, alpha) {
                alpha = Math.max(0.01, Math.min(0.99, alpha / 50)); // è°ƒæ•´å‚æ•°èŒƒå›´
                const result = [data[0]];
                
                for (let i = 1; i < data.length; i++) {
                    result.push(alpha * data[i] + (1 - alpha) * result[i - 1]);
                }
                
                return result;
            },
            
            // ä¸­å€¼æ»¤æ³¢
            median: function(data, windowSize) {
                const result = [];
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < data.length; i++) {
                    const window = [];
                    
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(data.length - 1, i + halfWindow); j++) {
                        window.push(data[j]);
                    }
                    
                    window.sort((a, b) => a - b);
                    const median = window[Math.floor(window.length / 2)];
                    result.push(median);
                }
                
                return result;
            },
            
            // ç®€å•å¡å°”æ›¼æ»¤æ³¢
            kalman: function(data, processNoise) {
                processNoise = processNoise / 1000; // è°ƒæ•´å™ªå£°å‚æ•°
                const measurementNoise = 0.1;
                
                let estimate = data[0];
                let errorEstimate = 1.0;
                const result = [estimate];
                
                for (let i = 1; i < data.length; i++) {
                    // é¢„æµ‹
                    const prediction = estimate;
                    const predictionError = errorEstimate + processNoise;
                    
                    // æ›´æ–°
                    const kalmanGain = predictionError / (predictionError + measurementNoise);
                    estimate = prediction + kalmanGain * (data[i] - prediction);
                    errorEstimate = (1 - kalmanGain) * predictionError;
                    
                    result.push(estimate);
                }
                
                return result;
            }
        };
        
        // åˆå§‹åŒ–æ§åˆ¶å™¨
        document.addEventListener('DOMContentLoaded', function() {
            const enableFilter = document.getElementById('enableFilter');
            const filterControls = document.getElementById('filterControls');
            const windowSize = document.getElementById('windowSize');
            const windowSizeValue = document.getElementById('windowSizeValue');
            
            // æ»¤æ³¢å™¨æ§åˆ¶
            enableFilter.addEventListener('change', function() {
                filterControls.style.display = this.checked ? 'block' : 'none';
            });
            
            windowSize.addEventListener('input', function() {
                windowSizeValue.textContent = this.value;
            });
            
            // æ—¶é—´èŒƒå›´æ§åˆ¶
            const enableTimeRange = document.getElementById('enableTimeRange');
            const timeRangeControls = document.getElementById('timeRangeControls');
            
            enableTimeRange.addEventListener('change', function() {
                timeRangeControls.style.display = this.checked ? 'block' : 'none';
                if (!this.checked) {
                    // ç¦ç”¨æ—¶é‡æ–°ç”Ÿæˆå›¾è¡¨
                    updateChart();
                }
            });
            
            // åˆå§‹åŒ–å¸®åŠ©é¢æ¿
            updateFilterHelp();
        });
        
        // æ—¶é—´èŒƒå›´ç›¸å…³å‡½æ•°
        function updateTimeRange() {
            if (!fileData || !originalData) return;
            
            const enableTimeRange = document.getElementById('enableTimeRange').checked;
            if (!enableTimeRange) return;
            
            const timeStart = parseFloat(document.getElementById('timeStart').value);
            const timeEnd = parseFloat(document.getElementById('timeEnd').value);
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            const minTime = Math.min(...timeValues);
            const maxTime = Math.max(...timeValues);
            
            // éªŒè¯è¾“å…¥
            let validStart = isNaN(timeStart) ? minTime : Math.max(timeStart, minTime);
            let validEnd = isNaN(timeEnd) ? maxTime : Math.min(timeEnd, maxTime);
            
            if (validStart >= validEnd) {
                validStart = minTime;
                validEnd = maxTime;
            }
            
            // æ›´æ–°è¾“å…¥æ¡†å€¼
            document.getElementById('timeStart').value = validStart;
            document.getElementById('timeEnd').value = validEnd;
            
            // è®¡ç®—ç­›é€‰åçš„æ•°æ®ç‚¹æ•°é‡
            const filteredCount = originalData.filter(row => {
                const time = row[timeColumn];
                return time >= validStart && time <= validEnd;
            }).length;
            
            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            const infoDiv = document.getElementById('timeRangeInfo');
            infoDiv.innerHTML = `
                <strong>æ—¶é—´èŒƒå›´ï¼š</strong> ${formatNumber(validStart)} ~ ${formatNumber(validEnd)}<br>
                <strong>æ•°æ®ç‚¹æ•°ï¼š</strong> ${filteredCount} / ${originalData.length} 
                <span style="color: #2196F3;">(${((filteredCount/originalData.length)*100).toFixed(1)}%)</span>
            `;
            
            // è‡ªåŠ¨æ›´æ–°å›¾è¡¨
            updateChart();
        }
        
        function resetTimeRange() {
            if (!fileData || !originalData) return;
            
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            const minTime = Math.min(...timeValues);
            const maxTime = Math.max(...timeValues);
            
            document.getElementById('timeStart').value = minTime;
            document.getElementById('timeEnd').value = maxTime;
            
            updateTimeRange();
        }
        
        function initializeTimeRange() {
            if (!fileData || !originalData) return;
            
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            const minTime = Math.min(...timeValues);
            const maxTime = Math.max(...timeValues);
            
            // è®¾ç½®é»˜è®¤å€¼å’Œå ä½ç¬¦
            document.getElementById('timeStart').placeholder = `æœ€å°: ${formatNumber(minTime)}`;
            document.getElementById('timeEnd').placeholder = `æœ€å¤§: ${formatNumber(maxTime)}`;
            document.getElementById('timeStart').value = '';
            document.getElementById('timeEnd').value = '';
            
            // æ›´æ–°ä¿¡æ¯
            const infoDiv = document.getElementById('timeRangeInfo');
            infoDiv.innerHTML = `
                <strong>æ•°æ®æ—¶é—´èŒƒå›´ï¼š</strong> ${formatNumber(minTime)} ~ ${formatNumber(maxTime)}<br>
                <strong>æ€»æ•°æ®ç‚¹æ•°ï¼š</strong> ${originalData.length}
            `;
        }
        
        // åˆ‡æ¢å¸®åŠ©é¢æ¿æ˜¾ç¤º
        function toggleFilterHelp() {
            const helpPanel = document.getElementById('filterHelpPanel');
            const isVisible = helpPanel.style.display === 'block';
            helpPanel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                updateFilterHelp();
            }
        }
        
        // æ•°æ®åˆ—ç­›é€‰åŠŸèƒ½
        function filterColumns() {
            const searchTerm = document.getElementById('columnSearch').value.toLowerCase();
            const checkboxContainer = document.getElementById('columnCheckboxes');
            const checkboxItems = checkboxContainer.querySelectorAll('.checkbox-item');
            
            let visibleCount = 0;
            
            checkboxItems.forEach(item => {
                const label = item.querySelector('label');
                const columnName = label.textContent.toLowerCase();
                
                if (columnName.includes(searchTerm)) {
                    item.style.display = 'flex';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                }
            });
            
            // æ›´æ–°ç­›é€‰å…¨é€‰æŒ‰é’®çŠ¶æ€
            updateFilteredSelectAllButtonState();
            
            // æ˜¾ç¤ºç­›é€‰ç»“æœç»Ÿè®¡
            const filteredBtn = document.getElementById('filteredSelectAllBtn');
            if (searchTerm.trim() === '') {
                filteredBtn.textContent = 'âœ“ ç­›é€‰å…¨é€‰';
            } else {
                filteredBtn.textContent = `âœ“ ç­›é€‰å…¨é€‰ (${visibleCount})`;
            }
        }
        
        function clearColumnSearch() {
            document.getElementById('columnSearch').value = '';
            filterColumns();
        }
        
        function toggleFilteredSelectAll() {
            const checkboxContainer = document.getElementById('columnCheckboxes');
            const visibleCheckboxes = [];
            
            // è·å–æ‰€æœ‰å¯è§çš„å¤é€‰æ¡†
            checkboxContainer.querySelectorAll('.checkbox-item').forEach(item => {
                if (item.style.display !== 'none') {
                    const checkbox = item.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        visibleCheckboxes.push(checkbox);
                    }
                }
            });
            
            if (visibleCheckboxes.length === 0) return;
            
            // æ£€æŸ¥å½“å‰çŠ¶æ€
            const checkedCount = visibleCheckboxes.filter(cb => cb.checked).length;
            const shouldSelectAll = checkedCount < visibleCheckboxes.length;
            
            // è®¾ç½®æ‰€æœ‰å¯è§å¤é€‰æ¡†çŠ¶æ€
            visibleCheckboxes.forEach(cb => {
                cb.checked = shouldSelectAll;
            });
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateFilteredSelectAllButtonState();
            updateSelectAllButtonState();
        }
        
        function updateFilteredSelectAllButtonState() {
            const filteredBtn = document.getElementById('filteredSelectAllBtn');
            const checkboxContainer = document.getElementById('columnCheckboxes');
            const visibleCheckboxes = [];
            
            // è·å–æ‰€æœ‰å¯è§çš„å¤é€‰æ¡†
            checkboxContainer.querySelectorAll('.checkbox-item').forEach(item => {
                if (item.style.display !== 'none') {
                    const checkbox = item.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        visibleCheckboxes.push(checkbox);
                    }
                }
            });
            
            if (visibleCheckboxes.length === 0) {
                filteredBtn.style.opacity = '0.5';
                return;
            }
            
            filteredBtn.style.opacity = '1';
            const checkedCount = visibleCheckboxes.filter(cb => cb.checked).length;
            const allSelected = checkedCount === visibleCheckboxes.length;
            const searchTerm = document.getElementById('columnSearch').value.trim();
            
            if (searchTerm === '') {
                filteredBtn.textContent = allSelected ? 'âœ— ç­›é€‰å…¨ä¸é€‰' : 'âœ“ ç­›é€‰å…¨é€‰';
            } else {
                filteredBtn.textContent = allSelected ? `âœ— ç­›é€‰å…¨ä¸é€‰ (${visibleCheckboxes.length})` : `âœ“ ç­›é€‰å…¨é€‰ (${visibleCheckboxes.length})`;
            }
        }
        
        // å…¨é€‰/å…¨ä¸é€‰åŠŸèƒ½
        function toggleSelectAll() {
            const checkboxes = document.querySelectorAll('#columnCheckboxes input[type="checkbox"]');
            const selectAllBtn = document.getElementById('selectAllBtn');
            
            if (checkboxes.length === 0) return;
            
            // æ£€æŸ¥å½“å‰çŠ¶æ€
            const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
            const shouldSelectAll = checkedCount < checkboxes.length;
            
            // è®¾ç½®æ‰€æœ‰å¤é€‰æ¡†çŠ¶æ€
            checkboxes.forEach(cb => {
                cb.checked = shouldSelectAll;
            });
            
            // æ›´æ–°æŒ‰é’®æ–‡å­—
            selectAllBtn.textContent = shouldSelectAll ? 'âœ— å…¨ä¸é€‰' : 'âœ“ å…¨é€‰';
        }
        
        // æ ¹æ®é€‰æ‹©çš„æ»¤æ³¢å™¨æ›´æ–°å¸®åŠ©å†…å®¹
        function updateFilterHelp() {
            const filterType = document.getElementById('filterType').value;
            const allHelps = document.querySelectorAll('.filter-info');
            
            // éšè—æ‰€æœ‰å¸®åŠ©ä¿¡æ¯
            allHelps.forEach(help => {
                help.style.display = 'none';
            });
            
            // æ˜¾ç¤ºå½“å‰é€‰æ‹©æ»¤æ³¢å™¨çš„å¸®åŠ©
            const currentHelp = document.getElementById(filterType + 'Help');
            if (currentHelp) {
                currentHelp.style.display = 'block';
            }
            
            // å§‹ç»ˆæ˜¾ç¤ºé€‰æ‹©å»ºè®®
            const suggestions = document.querySelector('#filterHelpPanel > div:last-child');
            if (suggestions) {
                suggestions.style.display = 'block';
            }
        }
        
        // æ‹–æ‹½å¤„ç†
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        function showError(message) {
            const errorDiv = document.getElementById('errorDiv');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        function hideError() {
            document.getElementById('errorDiv').style.display = 'none';
        }
        
        function handleFile(file) {
            hideError();
            
            // æ”¯æŒæ›´å¤šæ–‡ä»¶ç±»å‹
            const supportedExtensions = ['.tab', '.txt', '.csv', '.tsv', '.dat'];
            const fileName = file.name.toLowerCase();
            const isSupported = supportedExtensions.some(ext => fileName.endsWith(ext));
            
            if (!isSupported) {
                showError(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ã€‚æ”¯æŒçš„æ ¼å¼: ${supportedExtensions.join(', ')}`);
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    parseFile(e.target.result, file.name);
                } catch (error) {
                    showError('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message);
                    console.error('è§£æé”™è¯¯è¯¦æƒ…:', error);
                }
            };
            reader.readAsText(file);
        }
        
        function parseFile(content, filename) {
            // å¤„ç†ä¸åŒç±»å‹çš„æ¢è¡Œç¬¦
            const lines = content.trim().split(/\r?\n/);
            
            if (lines.length < 2) {
                throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œæ–‡ä»¶å†…å®¹è¿‡å°‘');
            }
            
            let headerLine = -1;
            let headers = [];
            
            // æ™ºèƒ½æ£€æµ‹è¡¨å¤´è¡Œ
            for (let i = 0; i < Math.min(lines.length, 10); i++) {
                const line = lines[i].trim();
                
                // è·³è¿‡ç©ºè¡Œå’Œçº¯æ•°å­—è¡Œ
                if (!line || /^\d+$/.test(line) || line.startsWith('"HQ_') || line.startsWith('HQ_')) {
                    continue;
                }
                
                // æ£€æµ‹æ˜¯å¦åŒ…å«å­—æ¯ï¼ˆå¯èƒ½æ˜¯è¡¨å¤´ï¼‰
                if (/[a-zA-Z]/.test(line)) {
                    // å°è¯•è§£æè¿™ä¸€è¡Œä½œä¸ºè¡¨å¤´
                    let potentialHeaders;
                    
                    // å…ˆå°è¯•åˆ¶è¡¨ç¬¦åˆ†éš”
                    if (line.includes('\t')) {
                        potentialHeaders = line.split('\t');
                    } else if (line.includes(',')) {
                        // å°è¯•é€—å·åˆ†éš”
                        potentialHeaders = line.split(',');
                    } else if (line.includes(' ')) {
                        // å°è¯•ç©ºæ ¼åˆ†éš”
                        potentialHeaders = line.split(/\s+/);
                    } else {
                        continue;
                    }
                    
                    // æ¸…ç†è¡¨å¤´ï¼šå»é™¤å¼•å·ã€ç©ºæ ¼ç­‰
                    const cleanHeaders = potentialHeaders.map(h => {
                        return h.trim()
                                .replace(/^["']|["']$/g, '') // å»é™¤å¼€å¤´ç»“å°¾çš„å¼•å·
                                .replace(/[^\w\s-_.]/g, '') // å»é™¤ç‰¹æ®Šå­—ç¬¦ï¼Œä¿ç•™å­—æ¯æ•°å­—ä¸‹åˆ’çº¿ç‚¹æ¨ªçº¿
                                .trim();
                    }).filter(h => h.length > 0);
                    
                    if (cleanHeaders.length >= 2) {
                        headerLine = i;
                        headers = cleanHeaders;
                        console.log(`æ£€æµ‹åˆ°è¡¨å¤´åœ¨ç¬¬${i+1}è¡Œ:`, headers);
                        break;
                    }
                }
            }
            
            if (headerLine === -1 || headers.length === 0) {
                throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„è¡¨å¤´è¡Œï¼Œè¯·ç¡®ä¿æ–‡ä»¶åŒ…å«åˆ—å');
            }
            
            // ä»è¡¨å¤´è¡Œä¹‹åå¼€å§‹è§£ææ•°æ®
            const data = [];
            let validDataCount = 0;
            
            for (let i = headerLine + 1; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // è·³è¿‡ç©ºè¡Œ
                if (!line) continue;
                
                // æ™ºèƒ½æ£€æµ‹åˆ†éš”ç¬¦
                let values;
                if (line.includes('\t')) {
                    values = line.split('\t');
                } else if (line.includes(',')) {
                    values = line.split(',');
                } else {
                    values = line.split(/\s+/);
                }
                
                // æ£€æŸ¥æ•°æ®è¡Œæ˜¯å¦æœ‰æ•ˆï¼ˆè‡³å°‘åŒ…å«ä¸€äº›æ•°å­—ï¼‰
                const numericValues = values.filter(v => {
                    const cleaned = v.trim().replace(/^["']|["']$/g, '');
                    return !isNaN(parseFloat(cleaned)) && isFinite(cleaned);
                });
                
                if (numericValues.length >= Math.min(2, headers.length)) {
                    const row = {};
                    let validColumns = 0;
                    
                    headers.forEach((header, index) => {
                        if (index < values.length) {
                            const cleanValue = values[index].trim().replace(/^["']|["']$/g, '');
                            const numValue = parseFloat(cleanValue);
                            
                            if (!isNaN(numValue) && isFinite(numValue)) {
                                row[header] = numValue;
                                validColumns++;
                            } else {
                                row[header] = 0; // é»˜è®¤å€¼
                            }
                        } else {
                            row[header] = 0;
                        }
                    });
                    
                    if (validColumns >= 1) {
                        data.push(row);
                        validDataCount++;
                    }
                }
                
                // é™åˆ¶å¤„ç†è¡Œæ•°ï¼Œé¿å…è¿‡å¤§æ–‡ä»¶å¡é¡¿
                if (validDataCount > 10000) {
                    console.warn('æ•°æ®è¡Œæ•°è¶…è¿‡10000è¡Œï¼Œå·²æˆªæ–­æ˜¾ç¤º');
                    break;
                }
            }
            
            if (data.length === 0) {
                throw new Error('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„æ•°æ®è¡Œï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
            }
            
            console.log(`æˆåŠŸè§£æ: ${headers.length}åˆ—, ${data.length}è¡Œæ•°æ®`);
            
            fileData = { headers, data, filename };
            originalData = JSON.parse(JSON.stringify(data)); // æ·±æ‹·è´åŸå§‹æ•°æ®
            
            // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            const fileInfo = document.getElementById('fileInfo');
            fileInfo.innerHTML = `
                <strong>æ–‡ä»¶:</strong> ${filename}<br>
                <strong>åˆ—æ•°:</strong> ${headers.length}<br>
                <strong>æ•°æ®è¡Œæ•°:</strong> ${data.length}<br>
                <strong>åˆ—å:</strong> ${headers.join(', ')}
            `;
            fileInfo.style.display = 'block';
            
            // åˆ›å»ºåˆ—é€‰æ‹©å¤é€‰æ¡†
            createColumnCheckboxes();
            
            // åˆå§‹åŒ–æ—¶é—´èŒƒå›´æ§åˆ¶
            initializeTimeRange();
            
            // æ˜¾ç¤ºæ§ä»¶å’Œå›¾è¡¨
            document.getElementById('controls').style.display = 'block';
            document.getElementById('chartContainer').style.display = 'block';
            document.getElementById('exportBtn').style.display = 'inline-block';
            
            // ç”Ÿæˆåˆå§‹å›¾è¡¨
            updateChart();
        }
        
        function createColumnCheckboxes() {
            const container = document.getElementById('columnCheckboxes');
            container.innerHTML = '';
            
            // å‡è®¾ç¬¬ä¸€åˆ—æ˜¯æ—¶é—´/Xè½´ï¼Œé»˜è®¤ä¸æ˜¾ç¤ºåœ¨é€‰é¡¹ä¸­
            const timeColumn = fileData.headers[0];
            
            fileData.headers.slice(1).forEach((header, index) => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `col_${index}`;
                checkbox.value = header;
                checkbox.checked = true; // é»˜è®¤å…¨é€‰
                
                // æ·»åŠ çŠ¶æ€å˜åŒ–ç›‘å¬å™¨
                checkbox.addEventListener('change', function() {
                    updateSelectAllButtonState();
                    updateFilteredSelectAllButtonState(); // åŒæ—¶æ›´æ–°ç­›é€‰æŒ‰é’®çŠ¶æ€
                });
                
                const label = document.createElement('label');
                label.htmlFor = `col_${index}`;
                label.textContent = header;
                label.style.fontWeight = 'normal';
                label.style.marginBottom = '0';
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
            
            // åˆå§‹åŒ–å…¨é€‰æŒ‰é’®çŠ¶æ€
            updateSelectAllButtonState();
            updateFilteredSelectAllButtonState();
        }
        
        // æ›´æ–°å…¨é€‰æŒ‰é’®çŠ¶æ€
        function updateSelectAllButtonState() {
            const checkboxes = document.querySelectorAll('#columnCheckboxes input[type="checkbox"]');
            const selectAllBtn = document.getElementById('selectAllBtn');
            
            if (checkboxes.length === 0) return;
            
            const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
            const allSelected = checkedCount === checkboxes.length;
            
            selectAllBtn.textContent = allSelected ? 'âœ— å…¨ä¸é€‰' : 'âœ“ å…¨é€‰';
        }
        
        function getChartColor(index) {
            // é¢„å®šä¹‰é«˜è´¨é‡é¢œè‰²
            const predefinedColors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                '#9966FF', '#FF9F40', '#e74c3c', '#2ecc71',
                '#f39c12', '#9b59b6', '#34495e', '#16a085',
                '#e67e22', '#c0392b', '#2980b9', '#27ae60',
                '#d35400', '#8e44ad', '#2c3e50', '#1abc9c'
            ];
            
            if (index < predefinedColors.length) {
                return predefinedColors[index];
            }
            
            // å½“è¶…å‡ºé¢„å®šä¹‰é¢œè‰²æ—¶ï¼Œä½¿ç”¨HSLç”Ÿæˆæ›´å¤šé¢œè‰²
            const hue = ((index - predefinedColors.length) * 137.5) % 360; // ä½¿ç”¨é»„é‡‘è§’åˆ†ç¦»
            const saturation = 70 + (index * 7) % 30; // 70-100%é¥±å’Œåº¦
            const lightness = 40 + (index * 5) % 20;  // 40-60%äº®åº¦
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        function updateChart() {
            if (!fileData) return;
            
            const selectedColumns = Array.from(document.querySelectorAll('#columnCheckboxes input:checked'))
                .map(cb => cb.value);
            
            if (selectedColumns.length === 0) {
                showError('è¯·è‡³å°‘é€‰æ‹©ä¸€åˆ—æ•°æ®');
                return;
            }
            
            hideError();
            
            const chartTitle = document.getElementById('chartTitle').value || 'æ•°æ®æ›²çº¿å›¾';
            document.getElementById('chartTitleDisplay').textContent = chartTitle;
            
            // è·å–æ—¶é—´èŒƒå›´è®¾ç½®
            const enableTimeRange = document.getElementById('enableTimeRange').checked;
            let currentData = originalData;
            
            // åº”ç”¨æ—¶é—´èŒƒå›´ç­›é€‰
            if (enableTimeRange) {
                const timeStart = parseFloat(document.getElementById('timeStart').value);
                const timeEnd = parseFloat(document.getElementById('timeEnd').value);
                const timeColumn = fileData.headers[0];
                
                if (!isNaN(timeStart) || !isNaN(timeEnd)) {
                    const minTime = isNaN(timeStart) ? -Infinity : timeStart;
                    const maxTime = isNaN(timeEnd) ? Infinity : timeEnd;
                    
                    currentData = originalData.filter(row => {
                        const time = row[timeColumn];
                        return time >= minTime && time <= maxTime;
                    });
                    
                    if (currentData.length === 0) {
                        showError('æ—¶é—´èŒƒå›´å†…æ²¡æœ‰æ•°æ®ç‚¹');
                        return;
                    }
                }
            }
            
            // è·å–æ»¤æ³¢è®¾ç½®
            const enableFilter = document.getElementById('enableFilter').checked;
            const filterType = document.getElementById('filterType').value;
            const windowSize = parseInt(document.getElementById('windowSize').value);
            const lineStyle = document.getElementById('lineStyle').value;
            
            // åº”ç”¨æ»¤æ³¢å™¨ï¼ˆåœ¨æ—¶é—´ç­›é€‰åçš„æ•°æ®ä¸Šï¼‰
            if (enableFilter) {
                const filteredData = currentData.map(row => ({ ...row })); // å¤åˆ¶æ•°æ®
                
                selectedColumns.forEach(column => {
                    const originalValues = currentData.map(row => row[column]);
                    let filteredValues;
                    
                    switch (filterType) {
                        case 'movingAverage':
                            filteredValues = Filters.movingAverage(originalValues, windowSize);
                            break;
                        case 'gaussian':
                            filteredValues = Filters.gaussian(originalValues, windowSize / 3);
                            break;
                        case 'butterworth':
                            filteredValues = Filters.butterworth(originalValues, windowSize);
                            break;
                        case 'median':
                            filteredValues = Filters.median(originalValues, windowSize);
                            break;
                        case 'kalman':
                            filteredValues = Filters.kalman(originalValues, windowSize);
                            break;
                        default:
                            filteredValues = originalValues;
                    }
                    
                    // æ›´æ–°æ•°æ®
                    filteredData.forEach((row, index) => {
                        row[column] = filteredValues[index];
                    });
                });
                
                currentData = filteredData;
            }
            
            // åˆ›å»ºç®€å•çš„SVGå›¾è¡¨
            drawSimpleChart(selectedColumns, currentData, enableFilter, filterType, lineStyle);
        }
        
        function getFilterName(filterType) {
            const names = {
                'movingAverage': 'ç§»åŠ¨å¹³å‡',
                'gaussian': 'é«˜æ–¯',
                'butterworth': 'å·´ç‰¹æ²ƒæ–¯',
                'median': 'ä¸­å€¼',
                'kalman': 'å¡å°”æ›¼'
            };
            return names[filterType] || filterType;
        }
        
        function drawSimpleChart(selectedColumns, currentData, enableFilter, filterType, lineStyle) {
            const svg = document.getElementById('chart');
            const timeColumn = fileData.headers[0];
            
            // æ¸…ç©ºSVG
            svg.innerHTML = '';
            
            // SVGå°ºå¯¸ - å¢åŠ å·¦è¾¹è·ä»¥å®¹çº³Yè½´æ ‡ç­¾
            const svgRect = svg.getBoundingClientRect();
            const leftMargin = 80;  // å¢åŠ å·¦è¾¹è·
            const rightMargin = 40;
            const topMargin = 40;
            const bottomMargin = 60; // å¢åŠ åº•éƒ¨è¾¹è·
            const width = svgRect.width - leftMargin - rightMargin;
            const height = svgRect.height - topMargin - bottomMargin;
            
            // è·å–æ•°æ®èŒƒå›´å¹¶æ·»åŠ é€‚å½“çš„è¾¹è·
            const xValues = currentData.map(row => row[timeColumn]);
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const xRange = xMax - xMin;
            const xPadding = xRange * 0.05; // 5%è¾¹è·
            const xMinPadded = xMin - xPadding;
            const xMaxPadded = xMax + xPadding;
            
            let yMin = Infinity, yMax = -Infinity;
            selectedColumns.forEach(column => {
                const values = currentData.map(row => row[column]);
                yMin = Math.min(yMin, ...values);
                yMax = Math.max(yMax, ...values);
            });
            const yRange = yMax - yMin;
            const yPadding = yRange * 0.1; // 10%è¾¹è·
            const yMinPadded = yMin - yPadding;
            const yMaxPadded = yMax + yPadding;
            
            // ç»˜åˆ¶åæ ‡è½´
            const axisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Xè½´
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', leftMargin);
            xAxis.setAttribute('y1', height + topMargin);
            xAxis.setAttribute('x2', width + leftMargin);
            xAxis.setAttribute('y2', height + topMargin);
            xAxis.setAttribute('stroke', '#333');
            xAxis.setAttribute('stroke-width', '1');
            axisGroup.appendChild(xAxis);
            
            // Yè½´
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', leftMargin);
            yAxis.setAttribute('y1', topMargin);
            yAxis.setAttribute('x2', leftMargin);
            yAxis.setAttribute('y2', height + topMargin);
            yAxis.setAttribute('stroke', '#333');
            yAxis.setAttribute('stroke-width', '1');
            axisGroup.appendChild(yAxis);
            
            // æ·»åŠ Xè½´åˆ»åº¦å’Œæ ‡ç­¾
            const xStep = (xMaxPadded - xMinPadded) / 8; // å¤§çº¦8ä¸ªåˆ»åº¦
            for (let i = 0; i <= 8; i++) {
                const xValue = xMinPadded + i * xStep;
                const x = leftMargin + i * (width / 8);
                
                // åˆ»åº¦çº¿
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', height + topMargin);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', height + topMargin + 5);
                tick.setAttribute('stroke', '#666');
                tick.setAttribute('stroke-width', '1');
                axisGroup.appendChild(tick);
                
                // åˆ»åº¦æ ‡ç­¾
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height + topMargin + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '10');
                label.setAttribute('fill', '#666');
                label.textContent = formatNumber(xValue);
                axisGroup.appendChild(label);
            }
            
            // æ·»åŠ Yè½´åˆ»åº¦å’Œæ ‡ç­¾
            const yStep = (yMaxPadded - yMinPadded) / 6; // å¤§çº¦6ä¸ªåˆ»åº¦
            for (let i = 0; i <= 6; i++) {
                const yValue = yMinPadded + i * yStep;
                const y = height + topMargin - i * (height / 6);
                
                // åˆ»åº¦çº¿
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', leftMargin - 5);
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', leftMargin);
                tick.setAttribute('y2', y);
                tick.setAttribute('stroke', '#666');
                tick.setAttribute('stroke-width', '1');
                axisGroup.appendChild(tick);
                
                // åˆ»åº¦æ ‡ç­¾ - å¢åŠ æ›´å¤šç©ºé—´
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin - 10);
                label.setAttribute('y', y + 3);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '10');
                label.setAttribute('fill', '#666');
                label.textContent = formatNumber(yValue);
                axisGroup.appendChild(label);
                
                // ç½‘æ ¼çº¿ï¼ˆå¯é€‰ï¼‰
                if (i > 0 && i < 6) {
                    const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    gridLine.setAttribute('x1', leftMargin);
                    gridLine.setAttribute('y1', y);
                    gridLine.setAttribute('x2', width + leftMargin);
                    gridLine.setAttribute('y2', y);
                    gridLine.setAttribute('stroke', '#eee');
                    gridLine.setAttribute('stroke-width', '1');
                    gridLine.setAttribute('stroke-dasharray', '2,2');
                    axisGroup.appendChild(gridLine);
                }
            }
            
            svg.appendChild(axisGroup);
            
            // ç»˜åˆ¶æ•°æ®çº¿
            const legend = document.getElementById('chartLegend');
            legend.innerHTML = '';
            
            selectedColumns.forEach((column, index) => {
                const color = getChartColor(index);
                const values = currentData.map(row => row[column]);
                
                if (lineStyle === 'points') {
                    // ä»…ç»˜åˆ¶æ•°æ®ç‚¹
                    values.forEach((value, i) => {
                        const x = leftMargin + (xValues[i] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                        const y = topMargin + height - (value - yMinPadded) / (yMaxPadded - yMinPadded) * height;
                        
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', 3);
                        circle.setAttribute('fill', color);
                        svg.appendChild(circle);
                    });
                } else {
                    // ç»˜åˆ¶çº¿æ¡
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let pathData = '';
                    
                    values.forEach((value, i) => {
                        const x = leftMargin + (xValues[i] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                        const y = topMargin + height - (value - yMinPadded) / (yMaxPadded - yMinPadded) * height;
                        
                        if (lineStyle === 'stepped' && i > 0) {
                            const prevX = leftMargin + (xValues[i-1] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                            pathData += ` L ${x} ${topMargin + height - (values[i-1] - yMinPadded) / (yMaxPadded - yMinPadded) * height}`;
                            pathData += ` L ${x} ${y}`;
                        } else {
                            if (i === 0) {
                                pathData += `M ${x} ${y}`;
                            } else {
                                pathData += ` L ${x} ${y}`;
                            }
                        }
                    });
                    
                    path.setAttribute('d', pathData);
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    
                    if (lineStyle === 'smooth') {
                        // ç®€åŒ–çš„å¹³æ»‘æ•ˆæœï¼Œä½¿ç”¨stroke-linejoin
                        path.setAttribute('stroke-linejoin', 'round');
                        path.setAttribute('stroke-linecap', 'round');
                    }
                    
                    svg.appendChild(path);
                }
                
                // æ·»åŠ å›¾ä¾‹
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                const legendColor = document.createElement('div');
                legendColor.className = 'legend-color';
                legendColor.style.backgroundColor = color;
                
                const legendText = document.createElement('span');
                legendText.textContent = column + (enableFilter ? ` (${getFilterName(filterType)})` : '');
                
                legendItem.appendChild(legendColor);
                legendItem.appendChild(legendText);
                legend.appendChild(legendItem);
            });
            
            // å…ˆæ·»åŠ æ‰€æœ‰æ•°æ®ç‚¹çš„å°åœ†ç‚¹ï¼ˆç”¨äºè§†è§‰æç¤ºï¼‰
            currentData.forEach((row, dataIndex) => {
                const x = leftMargin + (row[timeColumn] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                
                selectedColumns.forEach((column, index) => {
                    const y = topMargin + height - (row[column] - yMinPadded) / (yMaxPadded - yMinPadded) * height;
                    const color = getChartColor(index);
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('cx', x);
                    point.setAttribute('cy', y);
                    point.setAttribute('r', 2);
                    point.setAttribute('fill', color);
                    point.setAttribute('opacity', '0.6');
                    point.setAttribute('class', 'data-point');
                    point.style.pointerEvents = 'none'; // ç¡®ä¿å°ç‚¹ä¸é˜»æŒ¡é¼ æ ‡äº‹ä»¶
                    
                    svg.appendChild(point);
                });
            });
            
            // ç„¶åæ·»åŠ äº¤äº’åŒºåŸŸï¼ˆåœ¨æœ€ä¸Šå±‚ï¼Œç¡®ä¿èƒ½æ¥æ”¶é¼ æ ‡äº‹ä»¶ï¼‰
            currentData.forEach((row, dataIndex) => {
                const x = leftMargin + (row[timeColumn] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                
                // ä¸ºæ¯ä¸ªæ—¶é—´ç‚¹åˆ›å»ºä¸€ä¸ªå‚ç›´åŒºåŸŸæ¥è§¦å‘tooltip
                const interactionArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                interactionArea.setAttribute('x', x - 8);
                interactionArea.setAttribute('y', topMargin);
                interactionArea.setAttribute('width', 16);
                interactionArea.setAttribute('height', height);
                interactionArea.setAttribute('fill', 'transparent');
                interactionArea.setAttribute('stroke', 'none');
                interactionArea.style.cursor = 'pointer';
                interactionArea.style.pointerEvents = 'all';
                
                // æ·»åŠ tooltipäº‹ä»¶
                interactionArea.onmouseenter = function(event) {
                    showTooltip(event, row[timeColumn], row, selectedColumns);
                };
                
                interactionArea.onmouseleave = function() {
                    hideTooltip();
                };
                
                svg.appendChild(interactionArea);
            });
            
            // æ·»åŠ è½´æ ‡ç­¾
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', width/2 + leftMargin);
            xLabel.setAttribute('y', height + topMargin + 50);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('font-size', '12');
            xLabel.textContent = timeColumn;
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 15);
            yLabel.setAttribute('y', height/2 + topMargin);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('font-size', '12');
            yLabel.setAttribute('transform', `rotate(-90, 15, ${height/2 + topMargin})`);
            yLabel.textContent = 'æ•°å€¼';
            svg.appendChild(yLabel);
        }

        // Excelå¯¼å‡ºåŠŸèƒ½
        function exportToExcel() {
            if (!fileData || !fileData.data || fileData.data.length === 0) {
                showError('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®');
                return;
            }

            try {
                // æ£€æŸ¥XLSXåº“æ˜¯å¦å¯ç”¨
                if (typeof XLSX === 'undefined') {
                    showError('Excelå¯¼å‡ºåº“æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                    return;
                }

                // è·å–å½“å‰é€‰æ‹©çš„åˆ—
                const selectedColumns = Array.from(document.querySelectorAll('#columnCheckboxes input:checked'))
                    .map(cb => cb.value);

                if (selectedColumns.length === 0) {
                    showError('è¯·é€‰æ‹©è¦å¯¼å‡ºçš„æ•°æ®åˆ—');
                    return;
                }

                // è·å–æ—¶é—´èŒƒå›´è®¾ç½®
                const enableTimeRange = document.getElementById('enableTimeRange').checked;
                let exportData = originalData;

                // åº”ç”¨æ—¶é—´èŒƒå›´ç­›é€‰
                if (enableTimeRange) {
                    const timeStart = parseFloat(document.getElementById('timeStart').value);
                    const timeEnd = parseFloat(document.getElementById('timeEnd').value);
                    const timeColumn = fileData.headers[0];

                    if (!isNaN(timeStart) || !isNaN(timeEnd)) {
                        const minTime = isNaN(timeStart) ? -Infinity : timeStart;
                        const maxTime = isNaN(timeEnd) ? Infinity : timeEnd;

                        exportData = originalData.filter(row => {
                            const time = row[timeColumn];
                            return time >= minTime && time <= maxTime;
                        });

                        if (exportData.length === 0) {
                            showError('æ—¶é—´èŒƒå›´å†…æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
                            return;
                        }
                    }
                }

                // è·å–æ»¤æ³¢è®¾ç½®
                const enableFilter = document.getElementById('enableFilter').checked;
                const filterType = document.getElementById('filterType').value;
                const windowSize = parseInt(document.getElementById('windowSize').value);

                // å‡†å¤‡è¦å¯¼å‡ºçš„æ•°æ®
                const timeColumn = fileData.headers[0];
                let currentExportData = exportData;

                // å¦‚æœå¯ç”¨äº†æ»¤æ³¢ï¼Œä½¿ç”¨æ»¤æ³¢åçš„æ•°æ®
                if (enableFilter) {
                    currentExportData = exportData.map(row => ({ ...row })); // å¤åˆ¶æ•°æ®

                    selectedColumns.forEach(column => {
                        const originalValues = exportData.map(row => row[column]);
                        let filteredValues;

                        switch (filterType) {
                            case 'movingAverage':
                                filteredValues = Filters.movingAverage(originalValues, windowSize);
                                break;
                            case 'gaussian':
                                filteredValues = Filters.gaussian(originalValues, windowSize / 3);
                                break;
                            case 'butterworth':
                                filteredValues = Filters.butterworth(originalValues, windowSize);
                                break;
                            case 'median':
                                filteredValues = Filters.median(originalValues, windowSize);
                                break;
                            case 'kalman':
                                filteredValues = Filters.kalman(originalValues, windowSize);
                                break;
                            default:
                                filteredValues = originalValues;
                        }

                        currentExportData.forEach((row, index) => {
                            row[column] = filteredValues[index];
                        });
                    });
                }

                // åˆ›å»ºå·¥ä½œè¡¨æ•°æ®
                const wsData = [];

                // æ·»åŠ æ ‡é¢˜è¡Œ
                const headers = [timeColumn, ...selectedColumns];
                wsData.push(headers);

                // æ·»åŠ æ•°æ®è¡Œ
                currentExportData.forEach(row => {
                    const dataRow = [row[timeColumn]];
                    selectedColumns.forEach(col => {
                        dataRow.push(row[col]);
                    });
                    wsData.push(dataRow);
                });

                // åˆ›å»ºå·¥ä½œç°¿å’Œå·¥ä½œè¡¨
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(wsData);

                // è®¾ç½®åˆ—å®½
                const colWidths = headers.map(() => ({ width: 15 }));
                ws['!cols'] = colWidths;

                // è®¾ç½®æ ‡é¢˜è¡Œæ ·å¼ï¼ˆå¦‚æœæ”¯æŒçš„è¯ï¼‰
                const range = XLSX.utils.decode_range(ws['!ref']);
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const address = XLSX.utils.encode_cell({ r: 0, c: C });
                    if (!ws[address]) continue;
                    ws[address].s = {
                        font: { bold: true },
                        fill: { fgColor: { rgb: "E8F5E8" } }
                    };
                }

                // æ·»åŠ å·¥ä½œè¡¨åˆ°å·¥ä½œç°¿
                let sheetName = 'æ•°æ®';
                if (enableTimeRange) {
                    sheetName += '_æ—¶é—´ç­›é€‰';
                }
                if (enableFilter) {
                    sheetName += `_${getFilterName(filterType)}æ»¤æ³¢`;
                }
                XLSX.utils.book_append_sheet(wb, ws, sheetName);

                // å¦‚æœå¯ç”¨äº†æ»¤æ³¢æˆ–æ—¶é—´èŒƒå›´ç­›é€‰ï¼Œè¿˜å¯ä»¥æ·»åŠ åŸå§‹æ•°æ®è¡¨
                if (enableFilter || enableTimeRange) {
                    const originalWsData = [];
                    originalWsData.push(headers);

                    originalData.forEach(row => {
                        const dataRow = [row[timeColumn]];
                        selectedColumns.forEach(col => {
                            dataRow.push(row[col]);
                        });
                        originalWsData.push(dataRow);
                    });

                    const originalWs = XLSX.utils.aoa_to_sheet(originalWsData);
                    originalWs['!cols'] = colWidths;
                    XLSX.utils.book_append_sheet(wb, originalWs, 'åŸå§‹æ•°æ®');
                }

                // ç”Ÿæˆæ–‡ä»¶å
                const now = new Date();
                const timestamp = now.toISOString().slice(0, 19).replace(/[:\-T]/g, '');
                const baseFileName = fileData.filename.replace(/\.[^/.]+$/, "");
                let suffix = '';
                if (enableTimeRange) {
                    suffix += '_æ—¶é—´ç­›é€‰';
                }
                if (enableFilter) {
                    suffix += `_${getFilterName(filterType)}æ»¤æ³¢`;
                }
                const fileName = `${baseFileName}${suffix}_${timestamp}.xlsx`;

                // å¯¼å‡ºæ–‡ä»¶
                XLSX.writeFile(wb, fileName);

                // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                const errorDiv = document.getElementById('errorDiv');
                const originalBg = errorDiv.style.backgroundColor;
                const originalColor = errorDiv.style.color;

                errorDiv.innerHTML = `âœ… Excelæ–‡ä»¶å¯¼å‡ºæˆåŠŸï¼š${fileName}`;
                errorDiv.style.backgroundColor = '#e8f5e8';
                errorDiv.style.color = '#2e7d32';
                errorDiv.style.display = 'block';

                // 3ç§’åéšè—æ¶ˆæ¯å¹¶æ¢å¤åŸæ ·å¼
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                    errorDiv.style.backgroundColor = originalBg || '#ffebee';
                    errorDiv.style.color = originalColor || '#c62828';
                }, 3000);

            } catch (error) {
                showError('å¯¼å‡ºExcelæ–‡ä»¶å¤±è´¥: ' + error.message);
                console.error('å¯¼å‡ºé”™è¯¯:', error);
            }
        }
    </script>
</body>
</html>