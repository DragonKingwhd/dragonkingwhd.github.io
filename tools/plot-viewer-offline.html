<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLOT.tab 曲线图工具 (离线版)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- 内嵌简单的图表库 -->
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        
        .drop-zone {
            border: 3px dashed #4CAF50;
            border-radius: 10px;
            padding: 60px 20px;
            text-align: center;
            background-color: white;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #45a049;
            background-color: #f9f9f9;
            transform: scale(1.02);
        }
        
        .drop-zone p {
            margin: 10px 0;
            font-size: 18px;
            color: #666;
        }
        
        .drop-zone .icon {
            font-size: 48px;
            color: #4CAF50;
            margin-bottom: 20px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        
        .controls h3 {
            margin-top: 0;
            color: #333;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .checkbox-item input[type="checkbox"] {
            margin: 0;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        
        .file-info {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        
        button:hover {
            background: #45a049;
        }

        .export-button {
            background: #FF9800;
        }

        .export-button:hover {
            background: #F57C00;
        }
        
        /* 简单的SVG图表样式 */
        .simple-chart {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            background: white;
        }
        
        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 10px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
        }
        
        .chart-title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .help-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }
        
        .help-button:hover {
            background: #1976D2;
        }
        
        .help-panel {
            display: none;
            background: #f0f8ff;
            border: 1px solid #2196F3;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .help-panel h4 {
            margin: 0 0 10px 0;
            color: #1976D2;
        }
        
        .help-panel p {
            margin: 8px 0;
            line-height: 1.4;
            font-size: 14px;
        }
        
        .help-panel .filter-info {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .help-panel .filter-info:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .help-panel .highlight {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        /* Tooltip样式 */
        .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            font-family: monospace;
            pointer-events: none;
            z-index: 9999;
            display: none;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .chart-tooltip .tooltip-time {
            color: #66ccff;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .chart-tooltip .tooltip-value {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        
        .chart-tooltip .tooltip-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            margin-right: 6px;
        }
        
        /* 图表交互样式 */
        .chart-point {
            cursor: pointer;
            opacity: 0.7;
        }
        
        .chart-point:hover {
            opacity: 1;
            r: 6;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>📊 数据曲线图工具 (离线版)</h1>
        <p>将您的数据文件拖拽到下方区域，自动生成曲线图</p>
        <p><small>支持格式：.tab, .txt, .csv, .tsv, .dat | 此版本无需网络连接</small></p>
    </div>

    <div class="drop-zone" id="dropZone">
        <div class="icon">📁</div>
        <p><strong>拖拽数据文件到这里</strong></p>
        <p>支持 .tab/.txt/.csv/.tsv/.dat 格式</p>
        <p>或点击选择文件</p>
        <input type="file" id="fileInput" accept=".tab,.txt,.csv,.tsv,.dat" style="display: none;">
    </div>

    <div class="error" id="errorDiv"></div>
    
    <div class="file-info" id="fileInfo"></div>

    <div class="controls" id="controls">
        <h3>图表设置</h3>
        
        <div class="control-group">
            <label>选择要显示的数据列：
                <button type="button" class="help-button" onclick="toggleSelectAll()" id="selectAllBtn">✓ 全选</button>
            </label>
            
            <!-- 搜索筛选区域 -->
            <div style="margin: 10px 0; display: flex; gap: 10px; align-items: center;">
                <input type="text" id="columnSearch" placeholder="搜索数据列 (如: rb, motion, power...)" 
                       style="flex: 1; padding: 6px 10px; border: 1px solid #ddd; border-radius: 3px; font-size: 13px;"
                       oninput="filterColumns()" onkeyup="filterColumns()">
                <button type="button" onclick="clearColumnSearch()" 
                        style="background: #666; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                    清除
                </button>
                <button type="button" onclick="toggleFilteredSelectAll()" id="filteredSelectAllBtn"
                        style="background: #2196F3; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                    ✓ 筛选全选
                </button>
            </div>
            
            <div class="checkbox-group" id="columnCheckboxes"></div>
        </div>

        <div class="control-group">
            <label for="lineStyle">曲线样式：</label>
            <select id="lineStyle" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px;">
                <option value="smooth">平滑曲线 (推荐)</option>
                <option value="linear">直线连接</option>
                <option value="stepped">阶梯状</option>
                <option value="points">仅显示数据点</option>
            </select>
        </div>

        <div class="control-group">
            <label>数据滤波器：
                <button type="button" class="help-button" onclick="toggleFilterHelp()">❓ 帮助</button>
            </label>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" id="enableFilter">
                <label for="enableFilter" style="margin: 0; font-weight: normal;">启用滤波</label>
            </div>
            <div id="filterControls" style="display: none; border: 1px solid #ddd; padding: 15px; border-radius: 5px; background: #f9f9f9;">
                <div style="margin-bottom: 10px;">
                    <label for="filterType">滤波器类型：</label>
                    <select id="filterType" style="width: 100%; padding: 5px; margin-top: 5px;" onchange="updateFilterHelp()">
                        <option value="movingAverage">移动平均滤波</option>
                        <option value="gaussian">高斯滤波</option>
                        <option value="butterworth">巴特沃斯低通滤波</option>
                        <option value="median">中值滤波</option>
                        <option value="kalman">简单卡尔曼滤波</option>
                    </select>
                </div>
                <div id="filterParams">
                    <label for="windowSize">窗口大小/强度：</label>
                    <input type="range" id="windowSize" min="3" max="50" value="5" style="width: 100%;">
                    <span id="windowSizeValue">5</span>
                </div>
            </div>
            
            <!-- 滤波器帮助面板 -->
            <div id="filterHelpPanel" class="help-panel">
                <div id="movingAverageHelp" class="filter-info">
                    <h4>📊 移动平均滤波</h4>
                    <p><strong>特点：</strong>简单有效的噪声平滑算法，通过计算邻近点的平均值来减少随机噪声。</p>
                    <p><strong>适用场景：</strong></p>
                    <p>• 数据有随机噪声但趋势明显</p>
                    <p>• 需要简单快速的平滑效果</p>
                    <p>• 传感器数据预处理</p>
                    <p><strong>窗口大小选择：</strong></p>
                    <p>• <span class="highlight">3-7</span>：轻微平滑，保持细节</p>
                    <p>• <span class="highlight">8-15</span>：中等平滑，平衡噪声和细节</p>
                    <p>• <span class="highlight">16+</span>：强烈平滑，突出主要趋势</p>
                </div>
                
                <div id="gaussianHelp" class="filter-info">
                    <h4>🔔 高斯滤波</h4>
                    <p><strong>特点：</strong>基于高斯分布的加权平均，能更好地保持信号的边缘特征，平滑效果自然。</p>
                    <p><strong>适用场景：</strong></p>
                    <p>• 需要保持信号边缘和特征点</p>
                    <p>• 图像处理或精密测量数据</p>
                    <p>• 要求高质量平滑效果</p>
                    <p><strong>强度选择：</strong></p>
                    <p>• <span class="highlight">3-8</span>：轻微平滑，保持原始特征</p>
                    <p>• <span class="highlight">9-20</span>：适中平滑，去除中频噪声</p>
                    <p>• <span class="highlight">21+</span>：强烈平滑，仅保留主要趋势</p>
                </div>
                
                <div id="butterworthHelp" class="filter-info">
                    <h4>🌊 巴特沃斯低通滤波</h4>
                    <p><strong>特点：</strong>经典的频域滤波器，能有效去除高频噪声，保持低频信号完整性。</p>
                    <p><strong>适用场景：</strong></p>
                    <p>• 信号处理和频谱分析</p>
                    <p>• 去除已知频率范围的噪声</p>
                    <p>• 振动、声学数据处理</p>
                    <p><strong>强度选择：</strong></p>
                    <p>• <span class="highlight">5-15</span>：保留更多高频成分</p>
                    <p>• <span class="highlight">16-30</span>：平衡的频率响应</p>
                    <p>• <span class="highlight">31+</span>：强烈抑制高频噪声</p>
                </div>
                
                <div id="medianHelp" class="filter-info">
                    <h4>⚡ 中值滤波</h4>
                    <p><strong>特点：</strong>取窗口内数值的中位数，能有效去除脉冲噪声和异常值，同时保持边缘。</p>
                    <p><strong>适用场景：</strong></p>
                    <p>• 数据有尖峰噪声或异常值</p>
                    <p>• 需要保持信号跳变边缘</p>
                    <p>• 数字图像去噪</p>
                    <p><strong>窗口大小选择：</strong></p>
                    <p>• <span class="highlight">3-5</span>：去除小的异常点</p>
                    <p>• <span class="highlight">6-12</span>：处理中等脉冲噪声</p>
                    <p>• <span class="highlight">13+</span>：去除大范围异常区域</p>
                </div>
                
                <div id="kalmanHelp" class="filter-info">
                    <h4>🎯 简单卡尔曼滤波</h4>
                    <p><strong>特点：</strong>基于状态估计的自适应滤波器，能根据信号变化动态调整滤波强度。</p>
                    <p><strong>适用场景：</strong></p>
                    <p>• 动态系统状态估计</p>
                    <p>• 传感器融合和导航</p>
                    <p>• 需要跟踪信号变化趋势</p>
                    <p><strong>过程噪声选择：</strong></p>
                    <p>• <span class="highlight">5-15</span>：信号变化较慢</p>
                    <p>• <span class="highlight">16-30</span>：中等动态特性</p>
                    <p>• <span class="highlight">31+</span>：快速变化的动态信号</p>
                </div>
                
                <div style="background: #e8f4f8; padding: 10px; border-radius: 5px; margin-top: 15px;">
                    <h4>💡 选择建议</h4>
                    <p><strong>噪声类型识别：</strong></p>
                    <p>• 随机噪声 → 移动平均或高斯滤波</p>
                    <p>• 脉冲噪声 → 中值滤波</p>
                    <p>• 高频噪声 → 巴特沃斯滤波</p>
                    <p>• 动态信号 → 卡尔曼滤波</p>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="chartTitle">图表标题：</label>
            <input type="text" id="chartTitle" value="数据曲线图" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px;">
        </div>
        
        <div class="control-group">
            <label>时间范围限制（可选）：</label>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" id="enableTimeRange">
                <label for="enableTimeRange" style="margin: 0; font-weight: normal;">启用时间范围限制</label>
            </div>
            <div id="timeRangeControls" style="display: none; border: 1px solid #ddd; padding: 15px; border-radius: 5px; background: #f9f9f9;">
                <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <label for="timeStart" style="display: block; margin-bottom: 5px; font-size: 13px;">开始时间：</label>
                        <input type="number" id="timeStart" placeholder="最小时间值" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 3px;" 
                               step="any" onchange="updateTimeRange()">
                    </div>
                    <div style="flex: 1;">
                        <label for="timeEnd" style="display: block; margin-bottom: 5px; font-size: 13px;">结束时间：</label>
                        <input type="number" id="timeEnd" placeholder="最大时间值" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 3px;" 
                               step="any" onchange="updateTimeRange()">
                    </div>
                    <div>
                        <button type="button" onclick="resetTimeRange()" 
                                style="background: #666; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; margin-top: 20px;">
                            重置
                        </button>
                    </div>
                </div>
                <div id="timeRangeInfo" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="timePointQuery">查看特定时间点数据：</label>
            <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
                <input type="number" id="timePointInput" placeholder="输入时间值" 
                       style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 3px;" 
                       step="any" onkeypress="if(event.key==='Enter') queryTimePoint()">
                <button type="button" onclick="queryTimePoint()" style="background: #2196F3; min-width: 80px;">查询</button>
            </div>
            <div id="timePointResult" style="margin-top: 10px; padding: 10px; background: #f0f8ff; 
                                          border-radius: 5px; display: none; font-family: monospace; font-size: 13px;
                                          border: 1px solid #2196F3;"></div>
        </div>
        
        <button onclick="updateChart()">更新图表</button>
        <button class="export-button" onclick="exportToExcel()" id="exportBtn" style="display: none;">📊 导出Excel</button>
    </div>

    <div class="chart-container" id="chartContainer">
        <div class="chart-title" id="chartTitleDisplay">数据曲线图</div>
        <div class="chart-legend" id="chartLegend"></div>
        <svg class="simple-chart" id="chart"></svg>
        <!-- Tooltip元素 -->
        <div id="chartTooltip" class="chart-tooltip"></div>
    </div>

    <script>
        let fileData = null;
        let originalData = null; // 保存原始数据
        
        // 数据格式化函数
        function formatNumber(value) {
            if (typeof value !== 'number' || isNaN(value)) {
                return '0';
            }
            
            // 去除逗号分隔符，直接显示数字
            if (Math.abs(value) < 0.001 && value !== 0) {
                // 科学记数法显示非常小的数
                return value.toExponential(3);
            } else if (Math.abs(value) >= 1000000) {
                // 大数字使用科学记数法或简化显示
                return value.toExponential(3);
            } else {
                // 保留合适的小数位数
                let decimals = Math.abs(value) >= 1 ? 2 : 4;
                return value.toFixed(decimals).replace(/\.?0+$/, ''); // 去除末尾的0
            }
        }
        
        // Tooltip相关函数
        function showTooltip(event, timeValue, dataValues, selectedColumns) {
            const tooltip = document.getElementById('chartTooltip');
            if (!tooltip) {
                return;
            }
            
            const timeColumn = fileData.headers[0];
            
            let tooltipContent = `<div class="tooltip-time">${timeColumn}: ${formatNumber(timeValue)}</div>`;
            
            selectedColumns.forEach((column, index) => {
                const color = getChartColor(index);
                const value = dataValues[column];
                tooltipContent += `
                    <div class="tooltip-value">
                        <div class="tooltip-color" style="background-color: ${color}"></div>
                        <span>${column}: ${formatNumber(value)}</span>
                    </div>
                `;
            });
            
            tooltip.innerHTML = tooltipContent;
            
            // 显示tooltip
            tooltip.style.display = 'block';
            tooltip.style.visibility = 'visible';
            tooltip.style.opacity = '1';
            
            // 获取tooltip尺寸
            const tooltipRect = tooltip.getBoundingClientRect();
            
            // 计算相对于页面的位置
            let left = event.pageX + 15;
            let top = event.pageY - 10;
            
            // 防止tooltip超出视窗边界
            if (left + tooltipRect.width > window.innerWidth) {
                left = event.pageX - tooltipRect.width - 15;
            }
            if (top < window.pageYOffset) {
                top = event.pageY + 20;
            }
            if (top + tooltipRect.height > window.innerHeight + window.pageYOffset) {
                top = event.pageY - tooltipRect.height - 10;
            }
            
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('chartTooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
                tooltip.style.visibility = 'hidden';
                tooltip.style.opacity = '0';
            }
        }
        
        // 时间点查询功能
        function queryTimePoint() {
            if (!fileData || !originalData) {
                alert('请先加载数据文件');
                return;
            }
            
            const timeInput = document.getElementById('timePointInput');
            const resultDiv = document.getElementById('timePointResult');
            const queryTime = parseFloat(timeInput.value);
            
            if (isNaN(queryTime)) {
                alert('请输入有效的时间值');
                return;
            }
            
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            
            // 查找最接近的时间点
            let closestIndex = 0;
            let minDiff = Math.abs(timeValues[0] - queryTime);
            
            for (let i = 1; i < timeValues.length; i++) {
                const diff = Math.abs(timeValues[i] - queryTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }
            
            const closestTime = timeValues[closestIndex];
            const closestData = originalData[closestIndex];
            
            // 生成结果显示
            let resultHTML = `<strong>🎯 查询时间: ${formatNumber(queryTime)}</strong><br>`;
            resultHTML += `<strong>📍 最接近时间: ${formatNumber(closestTime)}</strong>`;
            
            if (Math.abs(closestTime - queryTime) > 0.001) {
                resultHTML += ` <span style="color: #666;">(偏差: ${formatNumber(Math.abs(closestTime - queryTime))})</span>`;
            }
            
            resultHTML += `<br><br><strong>📊 该时刻所有数据:</strong><br>`;
            
            // 显示所有列的数据
            fileData.headers.forEach((header, index) => {
                const value = closestData[header];
                const color = index === 0 ? '#2196F3' : getChartColor(index - 1); // 时间列用蓝色，其他用曲线颜色
                resultHTML += `<div style="margin: 3px 0; display: flex; align-items: center;">`;
                
                if (index > 0) { // 非时间列显示颜色块
                    resultHTML += `<div style="width: 12px; height: 12px; background-color: ${color}; 
                                    border-radius: 2px; margin-right: 8px;"></div>`;
                }
                
                resultHTML += `<span style="color: ${color}; font-weight: ${index === 0 ? 'bold' : 'normal'};">
                                ${header}: ${formatNumber(value)}</span></div>`;
            });
            
            // 如果启用了滤波，也显示滤波后的数据
            const enableFilter = document.getElementById('enableFilter').checked;
            if (enableFilter) {
                const filterType = document.getElementById('filterType').value;
                const windowSize = parseInt(document.getElementById('windowSize').value);
                
                // 获取选中的列
                const selectedColumns = Array.from(document.querySelectorAll('#columnCheckboxes input:checked'))
                    .map(cb => cb.value);
                
                if (selectedColumns.length > 0) {
                    resultHTML += `<br><strong>🔧 ${getFilterName(filterType)}滤波后数据:</strong><br>`;
                    
                    // 计算滤波后的数据
                    let filteredData = originalData.map(row => ({ ...row }));
                    
                    selectedColumns.forEach((column, colIndex) => {
                        const originalValues = originalData.map(row => row[column]);
                        let filteredValues;
                        
                        switch (filterType) {
                            case 'movingAverage':
                                filteredValues = Filters.movingAverage(originalValues, windowSize);
                                break;
                            case 'gaussian':
                                filteredValues = Filters.gaussian(originalValues, windowSize / 3);
                                break;
                            case 'butterworth':
                                filteredValues = Filters.butterworth(originalValues, windowSize);
                                break;
                            case 'median':
                                filteredValues = Filters.median(originalValues, windowSize);
                                break;
                            case 'kalman':
                                filteredValues = Filters.kalman(originalValues, windowSize);
                                break;
                            default:
                                filteredValues = originalValues;
                        }
                        
                        filteredData.forEach((row, index) => {
                            row[column] = filteredValues[index];
                        });
                    });
                    
                    const filteredClosestData = filteredData[closestIndex];
                    
                    selectedColumns.forEach((column, colIndex) => {
                        const value = filteredClosestData[column];
                        const color = getChartColor(colIndex);
                        resultHTML += `<div style="margin: 3px 0; display: flex; align-items: center;">`;
                        resultHTML += `<div style="width: 12px; height: 12px; background-color: ${color}; 
                                        border-radius: 2px; margin-right: 8px;"></div>`;
                        resultHTML += `<span style="color: ${color};">${column}: ${formatNumber(value)}</span></div>`;
                    });
                }
            }
            
            resultDiv.innerHTML = resultHTML;
            resultDiv.style.display = 'block';
            
            // 滚动到结果区域
            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // 滤波器实现 (与在线版本相同)
        const Filters = {
            // 移动平均滤波
            movingAverage: function(data, windowSize) {
                const result = [];
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < data.length; i++) {
                    let sum = 0;
                    let count = 0;
                    
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(data.length - 1, i + halfWindow); j++) {
                        sum += data[j];
                        count++;
                    }
                    
                    result.push(sum / count);
                }
                
                return result;
            },
            
            // 高斯滤波
            gaussian: function(data, sigma) {
                const kernelSize = Math.max(3, Math.ceil(sigma * 3) * 2 + 1);
                const kernel = [];
                const halfKernel = Math.floor(kernelSize / 2);
                let kernelSum = 0;
                
                // 生成高斯核
                for (let i = 0; i < kernelSize; i++) {
                    const x = i - halfKernel;
                    const value = Math.exp(-(x * x) / (2 * sigma * sigma));
                    kernel.push(value);
                    kernelSum += value;
                }
                
                // 归一化核
                for (let i = 0; i < kernel.length; i++) {
                    kernel[i] /= kernelSum;
                }
                
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    let sum = 0;
                    let weightSum = 0;
                    
                    for (let j = 0; j < kernelSize; j++) {
                        const dataIndex = i - halfKernel + j;
                        if (dataIndex >= 0 && dataIndex < data.length) {
                            sum += data[dataIndex] * kernel[j];
                            weightSum += kernel[j];
                        }
                    }
                    
                    result.push(sum / weightSum);
                }
                
                return result;
            },
            
            // 简单低通滤波器（巴特沃斯近似）
            butterworth: function(data, alpha) {
                alpha = Math.max(0.01, Math.min(0.99, alpha / 50)); // 调整参数范围
                const result = [data[0]];
                
                for (let i = 1; i < data.length; i++) {
                    result.push(alpha * data[i] + (1 - alpha) * result[i - 1]);
                }
                
                return result;
            },
            
            // 中值滤波
            median: function(data, windowSize) {
                const result = [];
                const halfWindow = Math.floor(windowSize / 2);
                
                for (let i = 0; i < data.length; i++) {
                    const window = [];
                    
                    for (let j = Math.max(0, i - halfWindow); j <= Math.min(data.length - 1, i + halfWindow); j++) {
                        window.push(data[j]);
                    }
                    
                    window.sort((a, b) => a - b);
                    const median = window[Math.floor(window.length / 2)];
                    result.push(median);
                }
                
                return result;
            },
            
            // 简单卡尔曼滤波
            kalman: function(data, processNoise) {
                processNoise = processNoise / 1000; // 调整噪声参数
                const measurementNoise = 0.1;
                
                let estimate = data[0];
                let errorEstimate = 1.0;
                const result = [estimate];
                
                for (let i = 1; i < data.length; i++) {
                    // 预测
                    const prediction = estimate;
                    const predictionError = errorEstimate + processNoise;
                    
                    // 更新
                    const kalmanGain = predictionError / (predictionError + measurementNoise);
                    estimate = prediction + kalmanGain * (data[i] - prediction);
                    errorEstimate = (1 - kalmanGain) * predictionError;
                    
                    result.push(estimate);
                }
                
                return result;
            }
        };
        
        // 初始化控制器
        document.addEventListener('DOMContentLoaded', function() {
            const enableFilter = document.getElementById('enableFilter');
            const filterControls = document.getElementById('filterControls');
            const windowSize = document.getElementById('windowSize');
            const windowSizeValue = document.getElementById('windowSizeValue');
            
            // 滤波器控制
            enableFilter.addEventListener('change', function() {
                filterControls.style.display = this.checked ? 'block' : 'none';
            });
            
            windowSize.addEventListener('input', function() {
                windowSizeValue.textContent = this.value;
            });
            
            // 时间范围控制
            const enableTimeRange = document.getElementById('enableTimeRange');
            const timeRangeControls = document.getElementById('timeRangeControls');
            
            enableTimeRange.addEventListener('change', function() {
                timeRangeControls.style.display = this.checked ? 'block' : 'none';
                if (!this.checked) {
                    // 禁用时重新生成图表
                    updateChart();
                }
            });
            
            // 初始化帮助面板
            updateFilterHelp();
        });
        
        // 时间范围相关函数
        function updateTimeRange() {
            if (!fileData || !originalData) return;
            
            const enableTimeRange = document.getElementById('enableTimeRange').checked;
            if (!enableTimeRange) return;
            
            const timeStart = parseFloat(document.getElementById('timeStart').value);
            const timeEnd = parseFloat(document.getElementById('timeEnd').value);
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            const minTime = Math.min(...timeValues);
            const maxTime = Math.max(...timeValues);
            
            // 验证输入
            let validStart = isNaN(timeStart) ? minTime : Math.max(timeStart, minTime);
            let validEnd = isNaN(timeEnd) ? maxTime : Math.min(timeEnd, maxTime);
            
            if (validStart >= validEnd) {
                validStart = minTime;
                validEnd = maxTime;
            }
            
            // 更新输入框值
            document.getElementById('timeStart').value = validStart;
            document.getElementById('timeEnd').value = validEnd;
            
            // 计算筛选后的数据点数量
            const filteredCount = originalData.filter(row => {
                const time = row[timeColumn];
                return time >= validStart && time <= validEnd;
            }).length;
            
            // 更新信息显示
            const infoDiv = document.getElementById('timeRangeInfo');
            infoDiv.innerHTML = `
                <strong>时间范围：</strong> ${formatNumber(validStart)} ~ ${formatNumber(validEnd)}<br>
                <strong>数据点数：</strong> ${filteredCount} / ${originalData.length} 
                <span style="color: #2196F3;">(${((filteredCount/originalData.length)*100).toFixed(1)}%)</span>
            `;
            
            // 自动更新图表
            updateChart();
        }
        
        function resetTimeRange() {
            if (!fileData || !originalData) return;
            
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            const minTime = Math.min(...timeValues);
            const maxTime = Math.max(...timeValues);
            
            document.getElementById('timeStart').value = minTime;
            document.getElementById('timeEnd').value = maxTime;
            
            updateTimeRange();
        }
        
        function initializeTimeRange() {
            if (!fileData || !originalData) return;
            
            const timeColumn = fileData.headers[0];
            const timeValues = originalData.map(row => row[timeColumn]);
            const minTime = Math.min(...timeValues);
            const maxTime = Math.max(...timeValues);
            
            // 设置默认值和占位符
            document.getElementById('timeStart').placeholder = `最小: ${formatNumber(minTime)}`;
            document.getElementById('timeEnd').placeholder = `最大: ${formatNumber(maxTime)}`;
            document.getElementById('timeStart').value = '';
            document.getElementById('timeEnd').value = '';
            
            // 更新信息
            const infoDiv = document.getElementById('timeRangeInfo');
            infoDiv.innerHTML = `
                <strong>数据时间范围：</strong> ${formatNumber(minTime)} ~ ${formatNumber(maxTime)}<br>
                <strong>总数据点数：</strong> ${originalData.length}
            `;
        }
        
        // 切换帮助面板显示
        function toggleFilterHelp() {
            const helpPanel = document.getElementById('filterHelpPanel');
            const isVisible = helpPanel.style.display === 'block';
            helpPanel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                updateFilterHelp();
            }
        }
        
        // 数据列筛选功能
        function filterColumns() {
            const searchTerm = document.getElementById('columnSearch').value.toLowerCase();
            const checkboxContainer = document.getElementById('columnCheckboxes');
            const checkboxItems = checkboxContainer.querySelectorAll('.checkbox-item');
            
            let visibleCount = 0;
            
            checkboxItems.forEach(item => {
                const label = item.querySelector('label');
                const columnName = label.textContent.toLowerCase();
                
                if (columnName.includes(searchTerm)) {
                    item.style.display = 'flex';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                }
            });
            
            // 更新筛选全选按钮状态
            updateFilteredSelectAllButtonState();
            
            // 显示筛选结果统计
            const filteredBtn = document.getElementById('filteredSelectAllBtn');
            if (searchTerm.trim() === '') {
                filteredBtn.textContent = '✓ 筛选全选';
            } else {
                filteredBtn.textContent = `✓ 筛选全选 (${visibleCount})`;
            }
        }
        
        function clearColumnSearch() {
            document.getElementById('columnSearch').value = '';
            filterColumns();
        }
        
        function toggleFilteredSelectAll() {
            const checkboxContainer = document.getElementById('columnCheckboxes');
            const visibleCheckboxes = [];
            
            // 获取所有可见的复选框
            checkboxContainer.querySelectorAll('.checkbox-item').forEach(item => {
                if (item.style.display !== 'none') {
                    const checkbox = item.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        visibleCheckboxes.push(checkbox);
                    }
                }
            });
            
            if (visibleCheckboxes.length === 0) return;
            
            // 检查当前状态
            const checkedCount = visibleCheckboxes.filter(cb => cb.checked).length;
            const shouldSelectAll = checkedCount < visibleCheckboxes.length;
            
            // 设置所有可见复选框状态
            visibleCheckboxes.forEach(cb => {
                cb.checked = shouldSelectAll;
            });
            
            // 更新按钮状态
            updateFilteredSelectAllButtonState();
            updateSelectAllButtonState();
        }
        
        function updateFilteredSelectAllButtonState() {
            const filteredBtn = document.getElementById('filteredSelectAllBtn');
            const checkboxContainer = document.getElementById('columnCheckboxes');
            const visibleCheckboxes = [];
            
            // 获取所有可见的复选框
            checkboxContainer.querySelectorAll('.checkbox-item').forEach(item => {
                if (item.style.display !== 'none') {
                    const checkbox = item.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        visibleCheckboxes.push(checkbox);
                    }
                }
            });
            
            if (visibleCheckboxes.length === 0) {
                filteredBtn.style.opacity = '0.5';
                return;
            }
            
            filteredBtn.style.opacity = '1';
            const checkedCount = visibleCheckboxes.filter(cb => cb.checked).length;
            const allSelected = checkedCount === visibleCheckboxes.length;
            const searchTerm = document.getElementById('columnSearch').value.trim();
            
            if (searchTerm === '') {
                filteredBtn.textContent = allSelected ? '✗ 筛选全不选' : '✓ 筛选全选';
            } else {
                filteredBtn.textContent = allSelected ? `✗ 筛选全不选 (${visibleCheckboxes.length})` : `✓ 筛选全选 (${visibleCheckboxes.length})`;
            }
        }
        
        // 全选/全不选功能
        function toggleSelectAll() {
            const checkboxes = document.querySelectorAll('#columnCheckboxes input[type="checkbox"]');
            const selectAllBtn = document.getElementById('selectAllBtn');
            
            if (checkboxes.length === 0) return;
            
            // 检查当前状态
            const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
            const shouldSelectAll = checkedCount < checkboxes.length;
            
            // 设置所有复选框状态
            checkboxes.forEach(cb => {
                cb.checked = shouldSelectAll;
            });
            
            // 更新按钮文字
            selectAllBtn.textContent = shouldSelectAll ? '✗ 全不选' : '✓ 全选';
        }
        
        // 根据选择的滤波器更新帮助内容
        function updateFilterHelp() {
            const filterType = document.getElementById('filterType').value;
            const allHelps = document.querySelectorAll('.filter-info');
            
            // 隐藏所有帮助信息
            allHelps.forEach(help => {
                help.style.display = 'none';
            });
            
            // 显示当前选择滤波器的帮助
            const currentHelp = document.getElementById(filterType + 'Help');
            if (currentHelp) {
                currentHelp.style.display = 'block';
            }
            
            // 始终显示选择建议
            const suggestions = document.querySelector('#filterHelpPanel > div:last-child');
            if (suggestions) {
                suggestions.style.display = 'block';
            }
        }
        
        // 拖拽处理
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        function showError(message) {
            const errorDiv = document.getElementById('errorDiv');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        function hideError() {
            document.getElementById('errorDiv').style.display = 'none';
        }
        
        function handleFile(file) {
            hideError();
            
            // 支持更多文件类型
            const supportedExtensions = ['.tab', '.txt', '.csv', '.tsv', '.dat'];
            const fileName = file.name.toLowerCase();
            const isSupported = supportedExtensions.some(ext => fileName.endsWith(ext));
            
            if (!isSupported) {
                showError(`不支持的文件类型。支持的格式: ${supportedExtensions.join(', ')}`);
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    parseFile(e.target.result, file.name);
                } catch (error) {
                    showError('文件解析失败: ' + error.message);
                    console.error('解析错误详情:', error);
                }
            };
            reader.readAsText(file);
        }
        
        function parseFile(content, filename) {
            // 处理不同类型的换行符
            const lines = content.trim().split(/\r?\n/);
            
            if (lines.length < 2) {
                throw new Error('文件格式不正确，文件内容过少');
            }
            
            let headerLine = -1;
            let headers = [];
            
            // 智能检测表头行
            for (let i = 0; i < Math.min(lines.length, 10); i++) {
                const line = lines[i].trim();
                
                // 跳过空行和纯数字行
                if (!line || /^\d+$/.test(line) || line.startsWith('"HQ_') || line.startsWith('HQ_')) {
                    continue;
                }
                
                // 检测是否包含字母（可能是表头）
                if (/[a-zA-Z]/.test(line)) {
                    // 尝试解析这一行作为表头
                    let potentialHeaders;
                    
                    // 先尝试制表符分隔
                    if (line.includes('\t')) {
                        potentialHeaders = line.split('\t');
                    } else if (line.includes(',')) {
                        // 尝试逗号分隔
                        potentialHeaders = line.split(',');
                    } else if (line.includes(' ')) {
                        // 尝试空格分隔
                        potentialHeaders = line.split(/\s+/);
                    } else {
                        continue;
                    }
                    
                    // 清理表头：去除引号、空格等
                    const cleanHeaders = potentialHeaders.map(h => {
                        return h.trim()
                                .replace(/^["']|["']$/g, '') // 去除开头结尾的引号
                                .replace(/[^\w\s-_.]/g, '') // 去除特殊字符，保留字母数字下划线点横线
                                .trim();
                    }).filter(h => h.length > 0);
                    
                    if (cleanHeaders.length >= 2) {
                        headerLine = i;
                        headers = cleanHeaders;
                        console.log(`检测到表头在第${i+1}行:`, headers);
                        break;
                    }
                }
            }
            
            if (headerLine === -1 || headers.length === 0) {
                throw new Error('未找到有效的表头行，请确保文件包含列名');
            }
            
            // 从表头行之后开始解析数据
            const data = [];
            let validDataCount = 0;
            
            for (let i = headerLine + 1; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // 跳过空行
                if (!line) continue;
                
                // 智能检测分隔符
                let values;
                if (line.includes('\t')) {
                    values = line.split('\t');
                } else if (line.includes(',')) {
                    values = line.split(',');
                } else {
                    values = line.split(/\s+/);
                }
                
                // 检查数据行是否有效（至少包含一些数字）
                const numericValues = values.filter(v => {
                    const cleaned = v.trim().replace(/^["']|["']$/g, '');
                    return !isNaN(parseFloat(cleaned)) && isFinite(cleaned);
                });
                
                if (numericValues.length >= Math.min(2, headers.length)) {
                    const row = {};
                    let validColumns = 0;
                    
                    headers.forEach((header, index) => {
                        if (index < values.length) {
                            const cleanValue = values[index].trim().replace(/^["']|["']$/g, '');
                            const numValue = parseFloat(cleanValue);
                            
                            if (!isNaN(numValue) && isFinite(numValue)) {
                                row[header] = numValue;
                                validColumns++;
                            } else {
                                row[header] = 0; // 默认值
                            }
                        } else {
                            row[header] = 0;
                        }
                    });
                    
                    if (validColumns >= 1) {
                        data.push(row);
                        validDataCount++;
                    }
                }
                
                // 限制处理行数，避免过大文件卡顿
                if (validDataCount > 10000) {
                    console.warn('数据行数超过10000行，已截断显示');
                    break;
                }
            }
            
            if (data.length === 0) {
                throw new Error('没有找到有效的数据行，请检查文件格式');
            }
            
            console.log(`成功解析: ${headers.length}列, ${data.length}行数据`);
            
            fileData = { headers, data, filename };
            originalData = JSON.parse(JSON.stringify(data)); // 深拷贝原始数据
            
            // 显示文件信息
            const fileInfo = document.getElementById('fileInfo');
            fileInfo.innerHTML = `
                <strong>文件:</strong> ${filename}<br>
                <strong>列数:</strong> ${headers.length}<br>
                <strong>数据行数:</strong> ${data.length}<br>
                <strong>列名:</strong> ${headers.join(', ')}
            `;
            fileInfo.style.display = 'block';
            
            // 创建列选择复选框
            createColumnCheckboxes();
            
            // 初始化时间范围控制
            initializeTimeRange();
            
            // 显示控件和图表
            document.getElementById('controls').style.display = 'block';
            document.getElementById('chartContainer').style.display = 'block';
            document.getElementById('exportBtn').style.display = 'inline-block';
            
            // 生成初始图表
            updateChart();
        }
        
        function createColumnCheckboxes() {
            const container = document.getElementById('columnCheckboxes');
            container.innerHTML = '';
            
            // 假设第一列是时间/X轴，默认不显示在选项中
            const timeColumn = fileData.headers[0];
            
            fileData.headers.slice(1).forEach((header, index) => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `col_${index}`;
                checkbox.value = header;
                checkbox.checked = true; // 默认全选
                
                // 添加状态变化监听器
                checkbox.addEventListener('change', function() {
                    updateSelectAllButtonState();
                    updateFilteredSelectAllButtonState(); // 同时更新筛选按钮状态
                });
                
                const label = document.createElement('label');
                label.htmlFor = `col_${index}`;
                label.textContent = header;
                label.style.fontWeight = 'normal';
                label.style.marginBottom = '0';
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
            
            // 初始化全选按钮状态
            updateSelectAllButtonState();
            updateFilteredSelectAllButtonState();
        }
        
        // 更新全选按钮状态
        function updateSelectAllButtonState() {
            const checkboxes = document.querySelectorAll('#columnCheckboxes input[type="checkbox"]');
            const selectAllBtn = document.getElementById('selectAllBtn');
            
            if (checkboxes.length === 0) return;
            
            const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
            const allSelected = checkedCount === checkboxes.length;
            
            selectAllBtn.textContent = allSelected ? '✗ 全不选' : '✓ 全选';
        }
        
        function getChartColor(index) {
            // 预定义高质量颜色
            const predefinedColors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                '#9966FF', '#FF9F40', '#e74c3c', '#2ecc71',
                '#f39c12', '#9b59b6', '#34495e', '#16a085',
                '#e67e22', '#c0392b', '#2980b9', '#27ae60',
                '#d35400', '#8e44ad', '#2c3e50', '#1abc9c'
            ];
            
            if (index < predefinedColors.length) {
                return predefinedColors[index];
            }
            
            // 当超出预定义颜色时，使用HSL生成更多颜色
            const hue = ((index - predefinedColors.length) * 137.5) % 360; // 使用黄金角分离
            const saturation = 70 + (index * 7) % 30; // 70-100%饱和度
            const lightness = 40 + (index * 5) % 20;  // 40-60%亮度
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        
        function updateChart() {
            if (!fileData) return;
            
            const selectedColumns = Array.from(document.querySelectorAll('#columnCheckboxes input:checked'))
                .map(cb => cb.value);
            
            if (selectedColumns.length === 0) {
                showError('请至少选择一列数据');
                return;
            }
            
            hideError();
            
            const chartTitle = document.getElementById('chartTitle').value || '数据曲线图';
            document.getElementById('chartTitleDisplay').textContent = chartTitle;
            
            // 获取时间范围设置
            const enableTimeRange = document.getElementById('enableTimeRange').checked;
            let currentData = originalData;
            
            // 应用时间范围筛选
            if (enableTimeRange) {
                const timeStart = parseFloat(document.getElementById('timeStart').value);
                const timeEnd = parseFloat(document.getElementById('timeEnd').value);
                const timeColumn = fileData.headers[0];
                
                if (!isNaN(timeStart) || !isNaN(timeEnd)) {
                    const minTime = isNaN(timeStart) ? -Infinity : timeStart;
                    const maxTime = isNaN(timeEnd) ? Infinity : timeEnd;
                    
                    currentData = originalData.filter(row => {
                        const time = row[timeColumn];
                        return time >= minTime && time <= maxTime;
                    });
                    
                    if (currentData.length === 0) {
                        showError('时间范围内没有数据点');
                        return;
                    }
                }
            }
            
            // 获取滤波设置
            const enableFilter = document.getElementById('enableFilter').checked;
            const filterType = document.getElementById('filterType').value;
            const windowSize = parseInt(document.getElementById('windowSize').value);
            const lineStyle = document.getElementById('lineStyle').value;
            
            // 应用滤波器（在时间筛选后的数据上）
            if (enableFilter) {
                const filteredData = currentData.map(row => ({ ...row })); // 复制数据
                
                selectedColumns.forEach(column => {
                    const originalValues = currentData.map(row => row[column]);
                    let filteredValues;
                    
                    switch (filterType) {
                        case 'movingAverage':
                            filteredValues = Filters.movingAverage(originalValues, windowSize);
                            break;
                        case 'gaussian':
                            filteredValues = Filters.gaussian(originalValues, windowSize / 3);
                            break;
                        case 'butterworth':
                            filteredValues = Filters.butterworth(originalValues, windowSize);
                            break;
                        case 'median':
                            filteredValues = Filters.median(originalValues, windowSize);
                            break;
                        case 'kalman':
                            filteredValues = Filters.kalman(originalValues, windowSize);
                            break;
                        default:
                            filteredValues = originalValues;
                    }
                    
                    // 更新数据
                    filteredData.forEach((row, index) => {
                        row[column] = filteredValues[index];
                    });
                });
                
                currentData = filteredData;
            }
            
            // 创建简单的SVG图表
            drawSimpleChart(selectedColumns, currentData, enableFilter, filterType, lineStyle);
        }
        
        function getFilterName(filterType) {
            const names = {
                'movingAverage': '移动平均',
                'gaussian': '高斯',
                'butterworth': '巴特沃斯',
                'median': '中值',
                'kalman': '卡尔曼'
            };
            return names[filterType] || filterType;
        }
        
        function drawSimpleChart(selectedColumns, currentData, enableFilter, filterType, lineStyle) {
            const svg = document.getElementById('chart');
            const timeColumn = fileData.headers[0];
            
            // 清空SVG
            svg.innerHTML = '';
            
            // SVG尺寸 - 增加左边距以容纳Y轴标签
            const svgRect = svg.getBoundingClientRect();
            const leftMargin = 80;  // 增加左边距
            const rightMargin = 40;
            const topMargin = 40;
            const bottomMargin = 60; // 增加底部边距
            const width = svgRect.width - leftMargin - rightMargin;
            const height = svgRect.height - topMargin - bottomMargin;
            
            // 获取数据范围并添加适当的边距
            const xValues = currentData.map(row => row[timeColumn]);
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const xRange = xMax - xMin;
            const xPadding = xRange * 0.05; // 5%边距
            const xMinPadded = xMin - xPadding;
            const xMaxPadded = xMax + xPadding;
            
            let yMin = Infinity, yMax = -Infinity;
            selectedColumns.forEach(column => {
                const values = currentData.map(row => row[column]);
                yMin = Math.min(yMin, ...values);
                yMax = Math.max(yMax, ...values);
            });
            const yRange = yMax - yMin;
            const yPadding = yRange * 0.1; // 10%边距
            const yMinPadded = yMin - yPadding;
            const yMaxPadded = yMax + yPadding;
            
            // 绘制坐标轴
            const axisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // X轴
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', leftMargin);
            xAxis.setAttribute('y1', height + topMargin);
            xAxis.setAttribute('x2', width + leftMargin);
            xAxis.setAttribute('y2', height + topMargin);
            xAxis.setAttribute('stroke', '#333');
            xAxis.setAttribute('stroke-width', '1');
            axisGroup.appendChild(xAxis);
            
            // Y轴
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', leftMargin);
            yAxis.setAttribute('y1', topMargin);
            yAxis.setAttribute('x2', leftMargin);
            yAxis.setAttribute('y2', height + topMargin);
            yAxis.setAttribute('stroke', '#333');
            yAxis.setAttribute('stroke-width', '1');
            axisGroup.appendChild(yAxis);
            
            // 添加X轴刻度和标签
            const xStep = (xMaxPadded - xMinPadded) / 8; // 大约8个刻度
            for (let i = 0; i <= 8; i++) {
                const xValue = xMinPadded + i * xStep;
                const x = leftMargin + i * (width / 8);
                
                // 刻度线
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', height + topMargin);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', height + topMargin + 5);
                tick.setAttribute('stroke', '#666');
                tick.setAttribute('stroke-width', '1');
                axisGroup.appendChild(tick);
                
                // 刻度标签
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height + topMargin + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '10');
                label.setAttribute('fill', '#666');
                label.textContent = formatNumber(xValue);
                axisGroup.appendChild(label);
            }
            
            // 添加Y轴刻度和标签
            const yStep = (yMaxPadded - yMinPadded) / 6; // 大约6个刻度
            for (let i = 0; i <= 6; i++) {
                const yValue = yMinPadded + i * yStep;
                const y = height + topMargin - i * (height / 6);
                
                // 刻度线
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', leftMargin - 5);
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', leftMargin);
                tick.setAttribute('y2', y);
                tick.setAttribute('stroke', '#666');
                tick.setAttribute('stroke-width', '1');
                axisGroup.appendChild(tick);
                
                // 刻度标签 - 增加更多空间
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin - 10);
                label.setAttribute('y', y + 3);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '10');
                label.setAttribute('fill', '#666');
                label.textContent = formatNumber(yValue);
                axisGroup.appendChild(label);
                
                // 网格线（可选）
                if (i > 0 && i < 6) {
                    const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    gridLine.setAttribute('x1', leftMargin);
                    gridLine.setAttribute('y1', y);
                    gridLine.setAttribute('x2', width + leftMargin);
                    gridLine.setAttribute('y2', y);
                    gridLine.setAttribute('stroke', '#eee');
                    gridLine.setAttribute('stroke-width', '1');
                    gridLine.setAttribute('stroke-dasharray', '2,2');
                    axisGroup.appendChild(gridLine);
                }
            }
            
            svg.appendChild(axisGroup);
            
            // 绘制数据线
            const legend = document.getElementById('chartLegend');
            legend.innerHTML = '';
            
            selectedColumns.forEach((column, index) => {
                const color = getChartColor(index);
                const values = currentData.map(row => row[column]);
                
                if (lineStyle === 'points') {
                    // 仅绘制数据点
                    values.forEach((value, i) => {
                        const x = leftMargin + (xValues[i] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                        const y = topMargin + height - (value - yMinPadded) / (yMaxPadded - yMinPadded) * height;
                        
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', 3);
                        circle.setAttribute('fill', color);
                        svg.appendChild(circle);
                    });
                } else {
                    // 绘制线条
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let pathData = '';
                    
                    values.forEach((value, i) => {
                        const x = leftMargin + (xValues[i] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                        const y = topMargin + height - (value - yMinPadded) / (yMaxPadded - yMinPadded) * height;
                        
                        if (lineStyle === 'stepped' && i > 0) {
                            const prevX = leftMargin + (xValues[i-1] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                            pathData += ` L ${x} ${topMargin + height - (values[i-1] - yMinPadded) / (yMaxPadded - yMinPadded) * height}`;
                            pathData += ` L ${x} ${y}`;
                        } else {
                            if (i === 0) {
                                pathData += `M ${x} ${y}`;
                            } else {
                                pathData += ` L ${x} ${y}`;
                            }
                        }
                    });
                    
                    path.setAttribute('d', pathData);
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    
                    if (lineStyle === 'smooth') {
                        // 简化的平滑效果，使用stroke-linejoin
                        path.setAttribute('stroke-linejoin', 'round');
                        path.setAttribute('stroke-linecap', 'round');
                    }
                    
                    svg.appendChild(path);
                }
                
                // 添加图例
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                const legendColor = document.createElement('div');
                legendColor.className = 'legend-color';
                legendColor.style.backgroundColor = color;
                
                const legendText = document.createElement('span');
                legendText.textContent = column + (enableFilter ? ` (${getFilterName(filterType)})` : '');
                
                legendItem.appendChild(legendColor);
                legendItem.appendChild(legendText);
                legend.appendChild(legendItem);
            });
            
            // 先添加所有数据点的小圆点（用于视觉提示）
            currentData.forEach((row, dataIndex) => {
                const x = leftMargin + (row[timeColumn] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                
                selectedColumns.forEach((column, index) => {
                    const y = topMargin + height - (row[column] - yMinPadded) / (yMaxPadded - yMinPadded) * height;
                    const color = getChartColor(index);
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('cx', x);
                    point.setAttribute('cy', y);
                    point.setAttribute('r', 2);
                    point.setAttribute('fill', color);
                    point.setAttribute('opacity', '0.6');
                    point.setAttribute('class', 'data-point');
                    point.style.pointerEvents = 'none'; // 确保小点不阻挡鼠标事件
                    
                    svg.appendChild(point);
                });
            });
            
            // 然后添加交互区域（在最上层，确保能接收鼠标事件）
            currentData.forEach((row, dataIndex) => {
                const x = leftMargin + (row[timeColumn] - xMinPadded) / (xMaxPadded - xMinPadded) * width;
                
                // 为每个时间点创建一个垂直区域来触发tooltip
                const interactionArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                interactionArea.setAttribute('x', x - 8);
                interactionArea.setAttribute('y', topMargin);
                interactionArea.setAttribute('width', 16);
                interactionArea.setAttribute('height', height);
                interactionArea.setAttribute('fill', 'transparent');
                interactionArea.setAttribute('stroke', 'none');
                interactionArea.style.cursor = 'pointer';
                interactionArea.style.pointerEvents = 'all';
                
                // 添加tooltip事件
                interactionArea.onmouseenter = function(event) {
                    showTooltip(event, row[timeColumn], row, selectedColumns);
                };
                
                interactionArea.onmouseleave = function() {
                    hideTooltip();
                };
                
                svg.appendChild(interactionArea);
            });
            
            // 添加轴标签
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', width/2 + leftMargin);
            xLabel.setAttribute('y', height + topMargin + 50);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('font-size', '12');
            xLabel.textContent = timeColumn;
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 15);
            yLabel.setAttribute('y', height/2 + topMargin);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('font-size', '12');
            yLabel.setAttribute('transform', `rotate(-90, 15, ${height/2 + topMargin})`);
            yLabel.textContent = '数值';
            svg.appendChild(yLabel);
        }

        // Excel导出功能
        function exportToExcel() {
            if (!fileData || !fileData.data || fileData.data.length === 0) {
                showError('没有可导出的数据');
                return;
            }

            try {
                // 检查XLSX库是否可用
                if (typeof XLSX === 'undefined') {
                    showError('Excel导出库未加载，请检查网络连接');
                    return;
                }

                // 获取当前选择的列
                const selectedColumns = Array.from(document.querySelectorAll('#columnCheckboxes input:checked'))
                    .map(cb => cb.value);

                if (selectedColumns.length === 0) {
                    showError('请选择要导出的数据列');
                    return;
                }

                // 获取时间范围设置
                const enableTimeRange = document.getElementById('enableTimeRange').checked;
                let exportData = originalData;

                // 应用时间范围筛选
                if (enableTimeRange) {
                    const timeStart = parseFloat(document.getElementById('timeStart').value);
                    const timeEnd = parseFloat(document.getElementById('timeEnd').value);
                    const timeColumn = fileData.headers[0];

                    if (!isNaN(timeStart) || !isNaN(timeEnd)) {
                        const minTime = isNaN(timeStart) ? -Infinity : timeStart;
                        const maxTime = isNaN(timeEnd) ? Infinity : timeEnd;

                        exportData = originalData.filter(row => {
                            const time = row[timeColumn];
                            return time >= minTime && time <= maxTime;
                        });

                        if (exportData.length === 0) {
                            showError('时间范围内没有数据可导出');
                            return;
                        }
                    }
                }

                // 获取滤波设置
                const enableFilter = document.getElementById('enableFilter').checked;
                const filterType = document.getElementById('filterType').value;
                const windowSize = parseInt(document.getElementById('windowSize').value);

                // 准备要导出的数据
                const timeColumn = fileData.headers[0];
                let currentExportData = exportData;

                // 如果启用了滤波，使用滤波后的数据
                if (enableFilter) {
                    currentExportData = exportData.map(row => ({ ...row })); // 复制数据

                    selectedColumns.forEach(column => {
                        const originalValues = exportData.map(row => row[column]);
                        let filteredValues;

                        switch (filterType) {
                            case 'movingAverage':
                                filteredValues = Filters.movingAverage(originalValues, windowSize);
                                break;
                            case 'gaussian':
                                filteredValues = Filters.gaussian(originalValues, windowSize / 3);
                                break;
                            case 'butterworth':
                                filteredValues = Filters.butterworth(originalValues, windowSize);
                                break;
                            case 'median':
                                filteredValues = Filters.median(originalValues, windowSize);
                                break;
                            case 'kalman':
                                filteredValues = Filters.kalman(originalValues, windowSize);
                                break;
                            default:
                                filteredValues = originalValues;
                        }

                        currentExportData.forEach((row, index) => {
                            row[column] = filteredValues[index];
                        });
                    });
                }

                // 创建工作表数据
                const wsData = [];

                // 添加标题行
                const headers = [timeColumn, ...selectedColumns];
                wsData.push(headers);

                // 添加数据行
                currentExportData.forEach(row => {
                    const dataRow = [row[timeColumn]];
                    selectedColumns.forEach(col => {
                        dataRow.push(row[col]);
                    });
                    wsData.push(dataRow);
                });

                // 创建工作簿和工作表
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(wsData);

                // 设置列宽
                const colWidths = headers.map(() => ({ width: 15 }));
                ws['!cols'] = colWidths;

                // 设置标题行样式（如果支持的话）
                const range = XLSX.utils.decode_range(ws['!ref']);
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const address = XLSX.utils.encode_cell({ r: 0, c: C });
                    if (!ws[address]) continue;
                    ws[address].s = {
                        font: { bold: true },
                        fill: { fgColor: { rgb: "E8F5E8" } }
                    };
                }

                // 添加工作表到工作簿
                let sheetName = '数据';
                if (enableTimeRange) {
                    sheetName += '_时间筛选';
                }
                if (enableFilter) {
                    sheetName += `_${getFilterName(filterType)}滤波`;
                }
                XLSX.utils.book_append_sheet(wb, ws, sheetName);

                // 如果启用了滤波或时间范围筛选，还可以添加原始数据表
                if (enableFilter || enableTimeRange) {
                    const originalWsData = [];
                    originalWsData.push(headers);

                    originalData.forEach(row => {
                        const dataRow = [row[timeColumn]];
                        selectedColumns.forEach(col => {
                            dataRow.push(row[col]);
                        });
                        originalWsData.push(dataRow);
                    });

                    const originalWs = XLSX.utils.aoa_to_sheet(originalWsData);
                    originalWs['!cols'] = colWidths;
                    XLSX.utils.book_append_sheet(wb, originalWs, '原始数据');
                }

                // 生成文件名
                const now = new Date();
                const timestamp = now.toISOString().slice(0, 19).replace(/[:\-T]/g, '');
                const baseFileName = fileData.filename.replace(/\.[^/.]+$/, "");
                let suffix = '';
                if (enableTimeRange) {
                    suffix += '_时间筛选';
                }
                if (enableFilter) {
                    suffix += `_${getFilterName(filterType)}滤波`;
                }
                const fileName = `${baseFileName}${suffix}_${timestamp}.xlsx`;

                // 导出文件
                XLSX.writeFile(wb, fileName);

                // 显示成功消息
                const errorDiv = document.getElementById('errorDiv');
                const originalBg = errorDiv.style.backgroundColor;
                const originalColor = errorDiv.style.color;

                errorDiv.innerHTML = `✅ Excel文件导出成功：${fileName}`;
                errorDiv.style.backgroundColor = '#e8f5e8';
                errorDiv.style.color = '#2e7d32';
                errorDiv.style.display = 'block';

                // 3秒后隐藏消息并恢复原样式
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                    errorDiv.style.backgroundColor = originalBg || '#ffebee';
                    errorDiv.style.color = originalColor || '#c62828';
                }, 3000);

            } catch (error) {
                showError('导出Excel文件失败: ' + error.message);
                console.error('导出错误:', error);
            }
        }
    </script>
</body>
</html>